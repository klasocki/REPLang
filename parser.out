Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> statement
Rule 1     statement -> expression
Rule 2     statement -> statement ; statement
Rule 3     convert -> 2INT
Rule 4     convert -> 2STR
Rule 5     convert -> 2FLOAT
Rule 6     convert -> 2BOOL
Rule 7     expression -> convert expression
Rule 8     expression -> NOT expression
Rule 9     expression -> PRINT expression
Rule 10    expression -> SIN expression
Rule 11    expression -> COS expression
Rule 12    expression -> NAME = expression
Rule 13    type -> STRING_TYPE
Rule 14    type -> INT_TYPE
Rule 15    type -> FLOAT_TYPE
Rule 16    type -> BOOL_TYPE
Rule 17    expression -> type NAME = expression
Rule 18    statement -> DEF NAME args - > type = expression
Rule 19    args -> empty
Rule 20    args -> type NAME args
Rule 21    expression -> NAME ( call_args )
Rule 22    call_args -> empty
Rule 23    call_args -> expression
Rule 24    call_args -> expression , call_args
Rule 25    expression -> error ; expression
Rule 26    expression -> expression ; expression
Rule 27    expression -> { expression }
Rule 28    expression -> IF expression THEN expression else_expression
Rule 29    else_expression -> ELSE expression
Rule 30    else_expression -> empty
Rule 31    expression -> WHILE expression DO expression END
Rule 32    expression -> expression + expression
Rule 33    expression -> expression - expression
Rule 34    expression -> expression * expression
Rule 35    expression -> expression / expression
Rule 36    expression -> expression POW expression
Rule 37    expression -> expression EQ expression
Rule 38    expression -> expression > expression
Rule 39    expression -> expression < expression
Rule 40    expression -> expression NEQ expression
Rule 41    expression -> - expression
Rule 42    expression -> ( expression )
Rule 43    expression -> NUMBER
Rule 44    expression -> FLOAT
Rule 45    expression -> STRING
Rule 46    expression -> TRUE
Rule 47    expression -> FALSE
Rule 48    expression -> NAME
Rule 49    empty -> <empty>

Terminals, with rules where they appear

(                    : 21 42
)                    : 21 42
*                    : 34
+                    : 32
,                    : 24
-                    : 18 33 41
/                    : 35
2BOOL                : 6
2FLOAT               : 5
2INT                 : 3
2STR                 : 4
;                    : 2 25 26
<                    : 39
=                    : 12 17 18
>                    : 18 38
BOOL_TYPE            : 16
COS                  : 11
DEF                  : 18
DO                   : 31
ELSE                 : 29
END                  : 31
EQ                   : 37
FALSE                : 47
FLOAT                : 44
FLOAT_TYPE           : 15
IF                   : 28
INT_TYPE             : 14
NAME                 : 12 17 18 20 21 48
NEQ                  : 40
NOT                  : 8
NUMBER               : 43
POW                  : 36
PRINT                : 9
SIN                  : 10
STRING               : 45
STRING_TYPE          : 13
THEN                 : 28
TRUE                 : 46
WHILE                : 31
error                : 25
{                    : 27
}                    : 27

Nonterminals, with rules where they appear

args                 : 18 20
call_args            : 21 24
convert              : 7
else_expression      : 28
empty                : 19 22 30
expression           : 1 7 8 9 10 11 12 17 18 23 24 25 26 26 27 28 28 29 31 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 42
statement            : 2 2 0
type                 : 17 18 20

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . expression
    (2) statement -> . statement ; statement
    (18) statement -> . DEF NAME args - > type = expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    DEF             shift and go to state 3
    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    statement                      shift and go to state 1
    expression                     shift and go to state 2
    type                           shift and go to state 6
    convert                        shift and go to state 7

state 1

    (0) S' -> statement .
    (2) statement -> statement . ; statement

    ;               shift and go to state 30


state 2

    (1) statement -> expression .
    (26) expression -> expression . ; expression
    (32) expression -> expression . + expression
    (33) expression -> expression . - expression
    (34) expression -> expression . * expression
    (35) expression -> expression . / expression
    (36) expression -> expression . POW expression
    (37) expression -> expression . EQ expression
    (38) expression -> expression . > expression
    (39) expression -> expression . < expression
    (40) expression -> expression . NEQ expression

  ! shift/reduce conflict for ; resolved as shift
    $end            reduce using rule 1 (statement -> expression .)
    ;               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    POW             shift and go to state 36
    EQ              shift and go to state 37
    >               shift and go to state 38
    <               shift and go to state 39
    NEQ             shift and go to state 40

  ! ;               [ reduce using rule 1 (statement -> expression .) ]


state 3

    (18) statement -> DEF . NAME args - > type = expression

    NAME            shift and go to state 41


state 4

    (12) expression -> NAME . = expression
    (21) expression -> NAME . ( call_args )
    (48) expression -> NAME .

    =               shift and go to state 42
    (               shift and go to state 43
    ;               reduce using rule 48 (expression -> NAME .)
    +               reduce using rule 48 (expression -> NAME .)
    -               reduce using rule 48 (expression -> NAME .)
    *               reduce using rule 48 (expression -> NAME .)
    /               reduce using rule 48 (expression -> NAME .)
    POW             reduce using rule 48 (expression -> NAME .)
    EQ              reduce using rule 48 (expression -> NAME .)
    >               reduce using rule 48 (expression -> NAME .)
    <               reduce using rule 48 (expression -> NAME .)
    NEQ             reduce using rule 48 (expression -> NAME .)
    $end            reduce using rule 48 (expression -> NAME .)
    )               reduce using rule 48 (expression -> NAME .)
    }               reduce using rule 48 (expression -> NAME .)
    THEN            reduce using rule 48 (expression -> NAME .)
    DO              reduce using rule 48 (expression -> NAME .)
    ,               reduce using rule 48 (expression -> NAME .)
    ELSE            reduce using rule 48 (expression -> NAME .)
    END             reduce using rule 48 (expression -> NAME .)


state 5

    (41) expression -> - . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    expression                     shift and go to state 44
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 6

    (17) expression -> type . NAME = expression

    NAME            shift and go to state 45


state 7

    (7) expression -> convert . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    convert                        shift and go to state 7
    expression                     shift and go to state 46
    type                           shift and go to state 6

state 8

    (8) expression -> NOT . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    expression                     shift and go to state 47
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 9

    (9) expression -> PRINT . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    expression                     shift and go to state 48
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 10

    (10) expression -> SIN . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    expression                     shift and go to state 49
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 11

    (11) expression -> COS . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    expression                     shift and go to state 50
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 12

    (42) expression -> ( . expression )
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    expression                     shift and go to state 51
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 13

    (25) expression -> error . ; expression

    ;               shift and go to state 52


state 14

    (27) expression -> { . expression }
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    expression                     shift and go to state 53
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 15

    (28) expression -> IF . expression THEN expression else_expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    expression                     shift and go to state 54
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 16

    (31) expression -> WHILE . expression DO expression END
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    expression                     shift and go to state 55
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 17

    (43) expression -> NUMBER .

    ;               reduce using rule 43 (expression -> NUMBER .)
    +               reduce using rule 43 (expression -> NUMBER .)
    -               reduce using rule 43 (expression -> NUMBER .)
    *               reduce using rule 43 (expression -> NUMBER .)
    /               reduce using rule 43 (expression -> NUMBER .)
    POW             reduce using rule 43 (expression -> NUMBER .)
    EQ              reduce using rule 43 (expression -> NUMBER .)
    >               reduce using rule 43 (expression -> NUMBER .)
    <               reduce using rule 43 (expression -> NUMBER .)
    NEQ             reduce using rule 43 (expression -> NUMBER .)
    $end            reduce using rule 43 (expression -> NUMBER .)
    )               reduce using rule 43 (expression -> NUMBER .)
    }               reduce using rule 43 (expression -> NUMBER .)
    THEN            reduce using rule 43 (expression -> NUMBER .)
    DO              reduce using rule 43 (expression -> NUMBER .)
    ,               reduce using rule 43 (expression -> NUMBER .)
    ELSE            reduce using rule 43 (expression -> NUMBER .)
    END             reduce using rule 43 (expression -> NUMBER .)


state 18

    (44) expression -> FLOAT .

    ;               reduce using rule 44 (expression -> FLOAT .)
    +               reduce using rule 44 (expression -> FLOAT .)
    -               reduce using rule 44 (expression -> FLOAT .)
    *               reduce using rule 44 (expression -> FLOAT .)
    /               reduce using rule 44 (expression -> FLOAT .)
    POW             reduce using rule 44 (expression -> FLOAT .)
    EQ              reduce using rule 44 (expression -> FLOAT .)
    >               reduce using rule 44 (expression -> FLOAT .)
    <               reduce using rule 44 (expression -> FLOAT .)
    NEQ             reduce using rule 44 (expression -> FLOAT .)
    $end            reduce using rule 44 (expression -> FLOAT .)
    )               reduce using rule 44 (expression -> FLOAT .)
    }               reduce using rule 44 (expression -> FLOAT .)
    THEN            reduce using rule 44 (expression -> FLOAT .)
    DO              reduce using rule 44 (expression -> FLOAT .)
    ,               reduce using rule 44 (expression -> FLOAT .)
    ELSE            reduce using rule 44 (expression -> FLOAT .)
    END             reduce using rule 44 (expression -> FLOAT .)


state 19

    (45) expression -> STRING .

    ;               reduce using rule 45 (expression -> STRING .)
    +               reduce using rule 45 (expression -> STRING .)
    -               reduce using rule 45 (expression -> STRING .)
    *               reduce using rule 45 (expression -> STRING .)
    /               reduce using rule 45 (expression -> STRING .)
    POW             reduce using rule 45 (expression -> STRING .)
    EQ              reduce using rule 45 (expression -> STRING .)
    >               reduce using rule 45 (expression -> STRING .)
    <               reduce using rule 45 (expression -> STRING .)
    NEQ             reduce using rule 45 (expression -> STRING .)
    $end            reduce using rule 45 (expression -> STRING .)
    )               reduce using rule 45 (expression -> STRING .)
    }               reduce using rule 45 (expression -> STRING .)
    THEN            reduce using rule 45 (expression -> STRING .)
    DO              reduce using rule 45 (expression -> STRING .)
    ,               reduce using rule 45 (expression -> STRING .)
    ELSE            reduce using rule 45 (expression -> STRING .)
    END             reduce using rule 45 (expression -> STRING .)


state 20

    (46) expression -> TRUE .

    ;               reduce using rule 46 (expression -> TRUE .)
    +               reduce using rule 46 (expression -> TRUE .)
    -               reduce using rule 46 (expression -> TRUE .)
    *               reduce using rule 46 (expression -> TRUE .)
    /               reduce using rule 46 (expression -> TRUE .)
    POW             reduce using rule 46 (expression -> TRUE .)
    EQ              reduce using rule 46 (expression -> TRUE .)
    >               reduce using rule 46 (expression -> TRUE .)
    <               reduce using rule 46 (expression -> TRUE .)
    NEQ             reduce using rule 46 (expression -> TRUE .)
    $end            reduce using rule 46 (expression -> TRUE .)
    )               reduce using rule 46 (expression -> TRUE .)
    }               reduce using rule 46 (expression -> TRUE .)
    THEN            reduce using rule 46 (expression -> TRUE .)
    DO              reduce using rule 46 (expression -> TRUE .)
    ,               reduce using rule 46 (expression -> TRUE .)
    ELSE            reduce using rule 46 (expression -> TRUE .)
    END             reduce using rule 46 (expression -> TRUE .)


state 21

    (47) expression -> FALSE .

    ;               reduce using rule 47 (expression -> FALSE .)
    +               reduce using rule 47 (expression -> FALSE .)
    -               reduce using rule 47 (expression -> FALSE .)
    *               reduce using rule 47 (expression -> FALSE .)
    /               reduce using rule 47 (expression -> FALSE .)
    POW             reduce using rule 47 (expression -> FALSE .)
    EQ              reduce using rule 47 (expression -> FALSE .)
    >               reduce using rule 47 (expression -> FALSE .)
    <               reduce using rule 47 (expression -> FALSE .)
    NEQ             reduce using rule 47 (expression -> FALSE .)
    $end            reduce using rule 47 (expression -> FALSE .)
    )               reduce using rule 47 (expression -> FALSE .)
    }               reduce using rule 47 (expression -> FALSE .)
    THEN            reduce using rule 47 (expression -> FALSE .)
    DO              reduce using rule 47 (expression -> FALSE .)
    ,               reduce using rule 47 (expression -> FALSE .)
    ELSE            reduce using rule 47 (expression -> FALSE .)
    END             reduce using rule 47 (expression -> FALSE .)


state 22

    (3) convert -> 2INT .

    NOT             reduce using rule 3 (convert -> 2INT .)
    PRINT           reduce using rule 3 (convert -> 2INT .)
    SIN             reduce using rule 3 (convert -> 2INT .)
    COS             reduce using rule 3 (convert -> 2INT .)
    NAME            reduce using rule 3 (convert -> 2INT .)
    error           reduce using rule 3 (convert -> 2INT .)
    {               reduce using rule 3 (convert -> 2INT .)
    IF              reduce using rule 3 (convert -> 2INT .)
    WHILE           reduce using rule 3 (convert -> 2INT .)
    -               reduce using rule 3 (convert -> 2INT .)
    (               reduce using rule 3 (convert -> 2INT .)
    NUMBER          reduce using rule 3 (convert -> 2INT .)
    FLOAT           reduce using rule 3 (convert -> 2INT .)
    STRING          reduce using rule 3 (convert -> 2INT .)
    TRUE            reduce using rule 3 (convert -> 2INT .)
    FALSE           reduce using rule 3 (convert -> 2INT .)
    2INT            reduce using rule 3 (convert -> 2INT .)
    2STR            reduce using rule 3 (convert -> 2INT .)
    2FLOAT          reduce using rule 3 (convert -> 2INT .)
    2BOOL           reduce using rule 3 (convert -> 2INT .)
    STRING_TYPE     reduce using rule 3 (convert -> 2INT .)
    INT_TYPE        reduce using rule 3 (convert -> 2INT .)
    FLOAT_TYPE      reduce using rule 3 (convert -> 2INT .)
    BOOL_TYPE       reduce using rule 3 (convert -> 2INT .)


state 23

    (4) convert -> 2STR .

    NOT             reduce using rule 4 (convert -> 2STR .)
    PRINT           reduce using rule 4 (convert -> 2STR .)
    SIN             reduce using rule 4 (convert -> 2STR .)
    COS             reduce using rule 4 (convert -> 2STR .)
    NAME            reduce using rule 4 (convert -> 2STR .)
    error           reduce using rule 4 (convert -> 2STR .)
    {               reduce using rule 4 (convert -> 2STR .)
    IF              reduce using rule 4 (convert -> 2STR .)
    WHILE           reduce using rule 4 (convert -> 2STR .)
    -               reduce using rule 4 (convert -> 2STR .)
    (               reduce using rule 4 (convert -> 2STR .)
    NUMBER          reduce using rule 4 (convert -> 2STR .)
    FLOAT           reduce using rule 4 (convert -> 2STR .)
    STRING          reduce using rule 4 (convert -> 2STR .)
    TRUE            reduce using rule 4 (convert -> 2STR .)
    FALSE           reduce using rule 4 (convert -> 2STR .)
    2INT            reduce using rule 4 (convert -> 2STR .)
    2STR            reduce using rule 4 (convert -> 2STR .)
    2FLOAT          reduce using rule 4 (convert -> 2STR .)
    2BOOL           reduce using rule 4 (convert -> 2STR .)
    STRING_TYPE     reduce using rule 4 (convert -> 2STR .)
    INT_TYPE        reduce using rule 4 (convert -> 2STR .)
    FLOAT_TYPE      reduce using rule 4 (convert -> 2STR .)
    BOOL_TYPE       reduce using rule 4 (convert -> 2STR .)


state 24

    (5) convert -> 2FLOAT .

    NOT             reduce using rule 5 (convert -> 2FLOAT .)
    PRINT           reduce using rule 5 (convert -> 2FLOAT .)
    SIN             reduce using rule 5 (convert -> 2FLOAT .)
    COS             reduce using rule 5 (convert -> 2FLOAT .)
    NAME            reduce using rule 5 (convert -> 2FLOAT .)
    error           reduce using rule 5 (convert -> 2FLOAT .)
    {               reduce using rule 5 (convert -> 2FLOAT .)
    IF              reduce using rule 5 (convert -> 2FLOAT .)
    WHILE           reduce using rule 5 (convert -> 2FLOAT .)
    -               reduce using rule 5 (convert -> 2FLOAT .)
    (               reduce using rule 5 (convert -> 2FLOAT .)
    NUMBER          reduce using rule 5 (convert -> 2FLOAT .)
    FLOAT           reduce using rule 5 (convert -> 2FLOAT .)
    STRING          reduce using rule 5 (convert -> 2FLOAT .)
    TRUE            reduce using rule 5 (convert -> 2FLOAT .)
    FALSE           reduce using rule 5 (convert -> 2FLOAT .)
    2INT            reduce using rule 5 (convert -> 2FLOAT .)
    2STR            reduce using rule 5 (convert -> 2FLOAT .)
    2FLOAT          reduce using rule 5 (convert -> 2FLOAT .)
    2BOOL           reduce using rule 5 (convert -> 2FLOAT .)
    STRING_TYPE     reduce using rule 5 (convert -> 2FLOAT .)
    INT_TYPE        reduce using rule 5 (convert -> 2FLOAT .)
    FLOAT_TYPE      reduce using rule 5 (convert -> 2FLOAT .)
    BOOL_TYPE       reduce using rule 5 (convert -> 2FLOAT .)


state 25

    (6) convert -> 2BOOL .

    NOT             reduce using rule 6 (convert -> 2BOOL .)
    PRINT           reduce using rule 6 (convert -> 2BOOL .)
    SIN             reduce using rule 6 (convert -> 2BOOL .)
    COS             reduce using rule 6 (convert -> 2BOOL .)
    NAME            reduce using rule 6 (convert -> 2BOOL .)
    error           reduce using rule 6 (convert -> 2BOOL .)
    {               reduce using rule 6 (convert -> 2BOOL .)
    IF              reduce using rule 6 (convert -> 2BOOL .)
    WHILE           reduce using rule 6 (convert -> 2BOOL .)
    -               reduce using rule 6 (convert -> 2BOOL .)
    (               reduce using rule 6 (convert -> 2BOOL .)
    NUMBER          reduce using rule 6 (convert -> 2BOOL .)
    FLOAT           reduce using rule 6 (convert -> 2BOOL .)
    STRING          reduce using rule 6 (convert -> 2BOOL .)
    TRUE            reduce using rule 6 (convert -> 2BOOL .)
    FALSE           reduce using rule 6 (convert -> 2BOOL .)
    2INT            reduce using rule 6 (convert -> 2BOOL .)
    2STR            reduce using rule 6 (convert -> 2BOOL .)
    2FLOAT          reduce using rule 6 (convert -> 2BOOL .)
    2BOOL           reduce using rule 6 (convert -> 2BOOL .)
    STRING_TYPE     reduce using rule 6 (convert -> 2BOOL .)
    INT_TYPE        reduce using rule 6 (convert -> 2BOOL .)
    FLOAT_TYPE      reduce using rule 6 (convert -> 2BOOL .)
    BOOL_TYPE       reduce using rule 6 (convert -> 2BOOL .)


state 26

    (13) type -> STRING_TYPE .

    NAME            reduce using rule 13 (type -> STRING_TYPE .)
    =               reduce using rule 13 (type -> STRING_TYPE .)


state 27

    (14) type -> INT_TYPE .

    NAME            reduce using rule 14 (type -> INT_TYPE .)
    =               reduce using rule 14 (type -> INT_TYPE .)


state 28

    (15) type -> FLOAT_TYPE .

    NAME            reduce using rule 15 (type -> FLOAT_TYPE .)
    =               reduce using rule 15 (type -> FLOAT_TYPE .)


state 29

    (16) type -> BOOL_TYPE .

    NAME            reduce using rule 16 (type -> BOOL_TYPE .)
    =               reduce using rule 16 (type -> BOOL_TYPE .)


state 30

    (2) statement -> statement ; . statement
    (1) statement -> . expression
    (2) statement -> . statement ; statement
    (18) statement -> . DEF NAME args - > type = expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    DEF             shift and go to state 3
    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    statement                      shift and go to state 56
    expression                     shift and go to state 2
    type                           shift and go to state 6
    convert                        shift and go to state 7

state 31

    (26) expression -> expression ; . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    expression                     shift and go to state 57
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 32

    (32) expression -> expression + . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    expression                     shift and go to state 58
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 33

    (33) expression -> expression - . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    expression                     shift and go to state 59
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 34

    (34) expression -> expression * . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    expression                     shift and go to state 60
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 35

    (35) expression -> expression / . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    expression                     shift and go to state 61
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 36

    (36) expression -> expression POW . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    expression                     shift and go to state 62
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 37

    (37) expression -> expression EQ . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    expression                     shift and go to state 63
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 38

    (38) expression -> expression > . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    expression                     shift and go to state 64
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 39

    (39) expression -> expression < . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    expression                     shift and go to state 65
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 40

    (40) expression -> expression NEQ . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    expression                     shift and go to state 66
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 41

    (18) statement -> DEF NAME . args - > type = expression
    (19) args -> . empty
    (20) args -> . type NAME args
    (49) empty -> .
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    -               reduce using rule 49 (empty -> .)
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    args                           shift and go to state 67
    type                           shift and go to state 68
    empty                          shift and go to state 69

state 42

    (12) expression -> NAME = . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    expression                     shift and go to state 70
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 43

    (21) expression -> NAME ( . call_args )
    (22) call_args -> . empty
    (23) call_args -> . expression
    (24) call_args -> . expression , call_args
    (49) empty -> .
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    )               reduce using rule 49 (empty -> .)
    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    call_args                      shift and go to state 71
    empty                          shift and go to state 72
    expression                     shift and go to state 73
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 44

    (41) expression -> - expression .
    (26) expression -> expression . ; expression
    (32) expression -> expression . + expression
    (33) expression -> expression . - expression
    (34) expression -> expression . * expression
    (35) expression -> expression . / expression
    (36) expression -> expression . POW expression
    (37) expression -> expression . EQ expression
    (38) expression -> expression . > expression
    (39) expression -> expression . < expression
    (40) expression -> expression . NEQ expression

    ;               reduce using rule 41 (expression -> - expression .)
    +               reduce using rule 41 (expression -> - expression .)
    -               reduce using rule 41 (expression -> - expression .)
    *               reduce using rule 41 (expression -> - expression .)
    /               reduce using rule 41 (expression -> - expression .)
    POW             reduce using rule 41 (expression -> - expression .)
    EQ              reduce using rule 41 (expression -> - expression .)
    >               reduce using rule 41 (expression -> - expression .)
    <               reduce using rule 41 (expression -> - expression .)
    NEQ             reduce using rule 41 (expression -> - expression .)
    $end            reduce using rule 41 (expression -> - expression .)
    )               reduce using rule 41 (expression -> - expression .)
    }               reduce using rule 41 (expression -> - expression .)
    THEN            reduce using rule 41 (expression -> - expression .)
    DO              reduce using rule 41 (expression -> - expression .)
    ,               reduce using rule 41 (expression -> - expression .)
    ELSE            reduce using rule 41 (expression -> - expression .)
    END             reduce using rule 41 (expression -> - expression .)

  ! ;               [ shift and go to state 31 ]
  ! +               [ shift and go to state 32 ]
  ! -               [ shift and go to state 33 ]
  ! *               [ shift and go to state 34 ]
  ! /               [ shift and go to state 35 ]
  ! POW             [ shift and go to state 36 ]
  ! EQ              [ shift and go to state 37 ]
  ! >               [ shift and go to state 38 ]
  ! <               [ shift and go to state 39 ]
  ! NEQ             [ shift and go to state 40 ]


state 45

    (17) expression -> type NAME . = expression

    =               shift and go to state 74


state 46

    (7) expression -> convert expression .
    (26) expression -> expression . ; expression
    (32) expression -> expression . + expression
    (33) expression -> expression . - expression
    (34) expression -> expression . * expression
    (35) expression -> expression . / expression
    (36) expression -> expression . POW expression
    (37) expression -> expression . EQ expression
    (38) expression -> expression . > expression
    (39) expression -> expression . < expression
    (40) expression -> expression . NEQ expression

  ! shift/reduce conflict for ; resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for POW resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
    $end            reduce using rule 7 (expression -> convert expression .)
    )               reduce using rule 7 (expression -> convert expression .)
    }               reduce using rule 7 (expression -> convert expression .)
    THEN            reduce using rule 7 (expression -> convert expression .)
    DO              reduce using rule 7 (expression -> convert expression .)
    ,               reduce using rule 7 (expression -> convert expression .)
    ELSE            reduce using rule 7 (expression -> convert expression .)
    END             reduce using rule 7 (expression -> convert expression .)
    ;               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    POW             shift and go to state 36
    EQ              shift and go to state 37
    >               shift and go to state 38
    <               shift and go to state 39
    NEQ             shift and go to state 40

  ! ;               [ reduce using rule 7 (expression -> convert expression .) ]
  ! +               [ reduce using rule 7 (expression -> convert expression .) ]
  ! -               [ reduce using rule 7 (expression -> convert expression .) ]
  ! *               [ reduce using rule 7 (expression -> convert expression .) ]
  ! /               [ reduce using rule 7 (expression -> convert expression .) ]
  ! POW             [ reduce using rule 7 (expression -> convert expression .) ]
  ! EQ              [ reduce using rule 7 (expression -> convert expression .) ]
  ! >               [ reduce using rule 7 (expression -> convert expression .) ]
  ! <               [ reduce using rule 7 (expression -> convert expression .) ]
  ! NEQ             [ reduce using rule 7 (expression -> convert expression .) ]


state 47

    (8) expression -> NOT expression .
    (26) expression -> expression . ; expression
    (32) expression -> expression . + expression
    (33) expression -> expression . - expression
    (34) expression -> expression . * expression
    (35) expression -> expression . / expression
    (36) expression -> expression . POW expression
    (37) expression -> expression . EQ expression
    (38) expression -> expression . > expression
    (39) expression -> expression . < expression
    (40) expression -> expression . NEQ expression

    ;               reduce using rule 8 (expression -> NOT expression .)
    EQ              reduce using rule 8 (expression -> NOT expression .)
    >               reduce using rule 8 (expression -> NOT expression .)
    <               reduce using rule 8 (expression -> NOT expression .)
    NEQ             reduce using rule 8 (expression -> NOT expression .)
    $end            reduce using rule 8 (expression -> NOT expression .)
    )               reduce using rule 8 (expression -> NOT expression .)
    }               reduce using rule 8 (expression -> NOT expression .)
    THEN            reduce using rule 8 (expression -> NOT expression .)
    DO              reduce using rule 8 (expression -> NOT expression .)
    ,               reduce using rule 8 (expression -> NOT expression .)
    ELSE            reduce using rule 8 (expression -> NOT expression .)
    END             reduce using rule 8 (expression -> NOT expression .)
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    POW             shift and go to state 36

  ! +               [ reduce using rule 8 (expression -> NOT expression .) ]
  ! -               [ reduce using rule 8 (expression -> NOT expression .) ]
  ! *               [ reduce using rule 8 (expression -> NOT expression .) ]
  ! /               [ reduce using rule 8 (expression -> NOT expression .) ]
  ! POW             [ reduce using rule 8 (expression -> NOT expression .) ]
  ! ;               [ shift and go to state 31 ]
  ! EQ              [ shift and go to state 37 ]
  ! >               [ shift and go to state 38 ]
  ! <               [ shift and go to state 39 ]
  ! NEQ             [ shift and go to state 40 ]


state 48

    (9) expression -> PRINT expression .
    (26) expression -> expression . ; expression
    (32) expression -> expression . + expression
    (33) expression -> expression . - expression
    (34) expression -> expression . * expression
    (35) expression -> expression . / expression
    (36) expression -> expression . POW expression
    (37) expression -> expression . EQ expression
    (38) expression -> expression . > expression
    (39) expression -> expression . < expression
    (40) expression -> expression . NEQ expression

    ;               reduce using rule 9 (expression -> PRINT expression .)
    $end            reduce using rule 9 (expression -> PRINT expression .)
    )               reduce using rule 9 (expression -> PRINT expression .)
    }               reduce using rule 9 (expression -> PRINT expression .)
    THEN            reduce using rule 9 (expression -> PRINT expression .)
    DO              reduce using rule 9 (expression -> PRINT expression .)
    ,               reduce using rule 9 (expression -> PRINT expression .)
    ELSE            reduce using rule 9 (expression -> PRINT expression .)
    END             reduce using rule 9 (expression -> PRINT expression .)
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    POW             shift and go to state 36
    EQ              shift and go to state 37
    >               shift and go to state 38
    <               shift and go to state 39
    NEQ             shift and go to state 40

  ! +               [ reduce using rule 9 (expression -> PRINT expression .) ]
  ! -               [ reduce using rule 9 (expression -> PRINT expression .) ]
  ! *               [ reduce using rule 9 (expression -> PRINT expression .) ]
  ! /               [ reduce using rule 9 (expression -> PRINT expression .) ]
  ! POW             [ reduce using rule 9 (expression -> PRINT expression .) ]
  ! EQ              [ reduce using rule 9 (expression -> PRINT expression .) ]
  ! >               [ reduce using rule 9 (expression -> PRINT expression .) ]
  ! <               [ reduce using rule 9 (expression -> PRINT expression .) ]
  ! NEQ             [ reduce using rule 9 (expression -> PRINT expression .) ]
  ! ;               [ shift and go to state 31 ]


state 49

    (10) expression -> SIN expression .
    (26) expression -> expression . ; expression
    (32) expression -> expression . + expression
    (33) expression -> expression . - expression
    (34) expression -> expression . * expression
    (35) expression -> expression . / expression
    (36) expression -> expression . POW expression
    (37) expression -> expression . EQ expression
    (38) expression -> expression . > expression
    (39) expression -> expression . < expression
    (40) expression -> expression . NEQ expression

    ;               reduce using rule 10 (expression -> SIN expression .)
    +               reduce using rule 10 (expression -> SIN expression .)
    -               reduce using rule 10 (expression -> SIN expression .)
    *               reduce using rule 10 (expression -> SIN expression .)
    /               reduce using rule 10 (expression -> SIN expression .)
    POW             reduce using rule 10 (expression -> SIN expression .)
    EQ              reduce using rule 10 (expression -> SIN expression .)
    >               reduce using rule 10 (expression -> SIN expression .)
    <               reduce using rule 10 (expression -> SIN expression .)
    NEQ             reduce using rule 10 (expression -> SIN expression .)
    $end            reduce using rule 10 (expression -> SIN expression .)
    )               reduce using rule 10 (expression -> SIN expression .)
    }               reduce using rule 10 (expression -> SIN expression .)
    THEN            reduce using rule 10 (expression -> SIN expression .)
    DO              reduce using rule 10 (expression -> SIN expression .)
    ,               reduce using rule 10 (expression -> SIN expression .)
    ELSE            reduce using rule 10 (expression -> SIN expression .)
    END             reduce using rule 10 (expression -> SIN expression .)

  ! ;               [ shift and go to state 31 ]
  ! +               [ shift and go to state 32 ]
  ! -               [ shift and go to state 33 ]
  ! *               [ shift and go to state 34 ]
  ! /               [ shift and go to state 35 ]
  ! POW             [ shift and go to state 36 ]
  ! EQ              [ shift and go to state 37 ]
  ! >               [ shift and go to state 38 ]
  ! <               [ shift and go to state 39 ]
  ! NEQ             [ shift and go to state 40 ]


state 50

    (11) expression -> COS expression .
    (26) expression -> expression . ; expression
    (32) expression -> expression . + expression
    (33) expression -> expression . - expression
    (34) expression -> expression . * expression
    (35) expression -> expression . / expression
    (36) expression -> expression . POW expression
    (37) expression -> expression . EQ expression
    (38) expression -> expression . > expression
    (39) expression -> expression . < expression
    (40) expression -> expression . NEQ expression

    ;               reduce using rule 11 (expression -> COS expression .)
    +               reduce using rule 11 (expression -> COS expression .)
    -               reduce using rule 11 (expression -> COS expression .)
    *               reduce using rule 11 (expression -> COS expression .)
    /               reduce using rule 11 (expression -> COS expression .)
    POW             reduce using rule 11 (expression -> COS expression .)
    EQ              reduce using rule 11 (expression -> COS expression .)
    >               reduce using rule 11 (expression -> COS expression .)
    <               reduce using rule 11 (expression -> COS expression .)
    NEQ             reduce using rule 11 (expression -> COS expression .)
    $end            reduce using rule 11 (expression -> COS expression .)
    )               reduce using rule 11 (expression -> COS expression .)
    }               reduce using rule 11 (expression -> COS expression .)
    THEN            reduce using rule 11 (expression -> COS expression .)
    DO              reduce using rule 11 (expression -> COS expression .)
    ,               reduce using rule 11 (expression -> COS expression .)
    ELSE            reduce using rule 11 (expression -> COS expression .)
    END             reduce using rule 11 (expression -> COS expression .)

  ! ;               [ shift and go to state 31 ]
  ! +               [ shift and go to state 32 ]
  ! -               [ shift and go to state 33 ]
  ! *               [ shift and go to state 34 ]
  ! /               [ shift and go to state 35 ]
  ! POW             [ shift and go to state 36 ]
  ! EQ              [ shift and go to state 37 ]
  ! >               [ shift and go to state 38 ]
  ! <               [ shift and go to state 39 ]
  ! NEQ             [ shift and go to state 40 ]


state 51

    (42) expression -> ( expression . )
    (26) expression -> expression . ; expression
    (32) expression -> expression . + expression
    (33) expression -> expression . - expression
    (34) expression -> expression . * expression
    (35) expression -> expression . / expression
    (36) expression -> expression . POW expression
    (37) expression -> expression . EQ expression
    (38) expression -> expression . > expression
    (39) expression -> expression . < expression
    (40) expression -> expression . NEQ expression

    )               shift and go to state 75
    ;               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    POW             shift and go to state 36
    EQ              shift and go to state 37
    >               shift and go to state 38
    <               shift and go to state 39
    NEQ             shift and go to state 40


state 52

    (25) expression -> error ; . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    expression                     shift and go to state 76
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 53

    (27) expression -> { expression . }
    (26) expression -> expression . ; expression
    (32) expression -> expression . + expression
    (33) expression -> expression . - expression
    (34) expression -> expression . * expression
    (35) expression -> expression . / expression
    (36) expression -> expression . POW expression
    (37) expression -> expression . EQ expression
    (38) expression -> expression . > expression
    (39) expression -> expression . < expression
    (40) expression -> expression . NEQ expression

    }               shift and go to state 77
    ;               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    POW             shift and go to state 36
    EQ              shift and go to state 37
    >               shift and go to state 38
    <               shift and go to state 39
    NEQ             shift and go to state 40


state 54

    (28) expression -> IF expression . THEN expression else_expression
    (26) expression -> expression . ; expression
    (32) expression -> expression . + expression
    (33) expression -> expression . - expression
    (34) expression -> expression . * expression
    (35) expression -> expression . / expression
    (36) expression -> expression . POW expression
    (37) expression -> expression . EQ expression
    (38) expression -> expression . > expression
    (39) expression -> expression . < expression
    (40) expression -> expression . NEQ expression

    THEN            shift and go to state 78
    ;               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    POW             shift and go to state 36
    EQ              shift and go to state 37
    >               shift and go to state 38
    <               shift and go to state 39
    NEQ             shift and go to state 40


state 55

    (31) expression -> WHILE expression . DO expression END
    (26) expression -> expression . ; expression
    (32) expression -> expression . + expression
    (33) expression -> expression . - expression
    (34) expression -> expression . * expression
    (35) expression -> expression . / expression
    (36) expression -> expression . POW expression
    (37) expression -> expression . EQ expression
    (38) expression -> expression . > expression
    (39) expression -> expression . < expression
    (40) expression -> expression . NEQ expression

    DO              shift and go to state 79
    ;               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    POW             shift and go to state 36
    EQ              shift and go to state 37
    >               shift and go to state 38
    <               shift and go to state 39
    NEQ             shift and go to state 40


state 56

    (2) statement -> statement ; statement .
    (2) statement -> statement . ; statement

    ;               reduce using rule 2 (statement -> statement ; statement .)
    $end            reduce using rule 2 (statement -> statement ; statement .)

  ! ;               [ shift and go to state 30 ]


state 57

    (26) expression -> expression ; expression .
    (26) expression -> expression . ; expression
    (32) expression -> expression . + expression
    (33) expression -> expression . - expression
    (34) expression -> expression . * expression
    (35) expression -> expression . / expression
    (36) expression -> expression . POW expression
    (37) expression -> expression . EQ expression
    (38) expression -> expression . > expression
    (39) expression -> expression . < expression
    (40) expression -> expression . NEQ expression

    ;               reduce using rule 26 (expression -> expression ; expression .)
    $end            reduce using rule 26 (expression -> expression ; expression .)
    )               reduce using rule 26 (expression -> expression ; expression .)
    }               reduce using rule 26 (expression -> expression ; expression .)
    THEN            reduce using rule 26 (expression -> expression ; expression .)
    DO              reduce using rule 26 (expression -> expression ; expression .)
    ,               reduce using rule 26 (expression -> expression ; expression .)
    ELSE            reduce using rule 26 (expression -> expression ; expression .)
    END             reduce using rule 26 (expression -> expression ; expression .)
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    POW             shift and go to state 36
    EQ              shift and go to state 37
    >               shift and go to state 38
    <               shift and go to state 39
    NEQ             shift and go to state 40

  ! +               [ reduce using rule 26 (expression -> expression ; expression .) ]
  ! -               [ reduce using rule 26 (expression -> expression ; expression .) ]
  ! *               [ reduce using rule 26 (expression -> expression ; expression .) ]
  ! /               [ reduce using rule 26 (expression -> expression ; expression .) ]
  ! POW             [ reduce using rule 26 (expression -> expression ; expression .) ]
  ! EQ              [ reduce using rule 26 (expression -> expression ; expression .) ]
  ! >               [ reduce using rule 26 (expression -> expression ; expression .) ]
  ! <               [ reduce using rule 26 (expression -> expression ; expression .) ]
  ! NEQ             [ reduce using rule 26 (expression -> expression ; expression .) ]
  ! ;               [ shift and go to state 31 ]


state 58

    (32) expression -> expression + expression .
    (26) expression -> expression . ; expression
    (32) expression -> expression . + expression
    (33) expression -> expression . - expression
    (34) expression -> expression . * expression
    (35) expression -> expression . / expression
    (36) expression -> expression . POW expression
    (37) expression -> expression . EQ expression
    (38) expression -> expression . > expression
    (39) expression -> expression . < expression
    (40) expression -> expression . NEQ expression

    ;               reduce using rule 32 (expression -> expression + expression .)
    +               reduce using rule 32 (expression -> expression + expression .)
    -               reduce using rule 32 (expression -> expression + expression .)
    EQ              reduce using rule 32 (expression -> expression + expression .)
    >               reduce using rule 32 (expression -> expression + expression .)
    <               reduce using rule 32 (expression -> expression + expression .)
    NEQ             reduce using rule 32 (expression -> expression + expression .)
    $end            reduce using rule 32 (expression -> expression + expression .)
    )               reduce using rule 32 (expression -> expression + expression .)
    }               reduce using rule 32 (expression -> expression + expression .)
    THEN            reduce using rule 32 (expression -> expression + expression .)
    DO              reduce using rule 32 (expression -> expression + expression .)
    ,               reduce using rule 32 (expression -> expression + expression .)
    ELSE            reduce using rule 32 (expression -> expression + expression .)
    END             reduce using rule 32 (expression -> expression + expression .)
    *               shift and go to state 34
    /               shift and go to state 35
    POW             shift and go to state 36

  ! *               [ reduce using rule 32 (expression -> expression + expression .) ]
  ! /               [ reduce using rule 32 (expression -> expression + expression .) ]
  ! POW             [ reduce using rule 32 (expression -> expression + expression .) ]
  ! ;               [ shift and go to state 31 ]
  ! +               [ shift and go to state 32 ]
  ! -               [ shift and go to state 33 ]
  ! EQ              [ shift and go to state 37 ]
  ! >               [ shift and go to state 38 ]
  ! <               [ shift and go to state 39 ]
  ! NEQ             [ shift and go to state 40 ]


state 59

    (33) expression -> expression - expression .
    (26) expression -> expression . ; expression
    (32) expression -> expression . + expression
    (33) expression -> expression . - expression
    (34) expression -> expression . * expression
    (35) expression -> expression . / expression
    (36) expression -> expression . POW expression
    (37) expression -> expression . EQ expression
    (38) expression -> expression . > expression
    (39) expression -> expression . < expression
    (40) expression -> expression . NEQ expression

    ;               reduce using rule 33 (expression -> expression - expression .)
    +               reduce using rule 33 (expression -> expression - expression .)
    -               reduce using rule 33 (expression -> expression - expression .)
    EQ              reduce using rule 33 (expression -> expression - expression .)
    >               reduce using rule 33 (expression -> expression - expression .)
    <               reduce using rule 33 (expression -> expression - expression .)
    NEQ             reduce using rule 33 (expression -> expression - expression .)
    $end            reduce using rule 33 (expression -> expression - expression .)
    )               reduce using rule 33 (expression -> expression - expression .)
    }               reduce using rule 33 (expression -> expression - expression .)
    THEN            reduce using rule 33 (expression -> expression - expression .)
    DO              reduce using rule 33 (expression -> expression - expression .)
    ,               reduce using rule 33 (expression -> expression - expression .)
    ELSE            reduce using rule 33 (expression -> expression - expression .)
    END             reduce using rule 33 (expression -> expression - expression .)
    *               shift and go to state 34
    /               shift and go to state 35
    POW             shift and go to state 36

  ! *               [ reduce using rule 33 (expression -> expression - expression .) ]
  ! /               [ reduce using rule 33 (expression -> expression - expression .) ]
  ! POW             [ reduce using rule 33 (expression -> expression - expression .) ]
  ! ;               [ shift and go to state 31 ]
  ! +               [ shift and go to state 32 ]
  ! -               [ shift and go to state 33 ]
  ! EQ              [ shift and go to state 37 ]
  ! >               [ shift and go to state 38 ]
  ! <               [ shift and go to state 39 ]
  ! NEQ             [ shift and go to state 40 ]


state 60

    (34) expression -> expression * expression .
    (26) expression -> expression . ; expression
    (32) expression -> expression . + expression
    (33) expression -> expression . - expression
    (34) expression -> expression . * expression
    (35) expression -> expression . / expression
    (36) expression -> expression . POW expression
    (37) expression -> expression . EQ expression
    (38) expression -> expression . > expression
    (39) expression -> expression . < expression
    (40) expression -> expression . NEQ expression

    ;               reduce using rule 34 (expression -> expression * expression .)
    +               reduce using rule 34 (expression -> expression * expression .)
    -               reduce using rule 34 (expression -> expression * expression .)
    *               reduce using rule 34 (expression -> expression * expression .)
    /               reduce using rule 34 (expression -> expression * expression .)
    EQ              reduce using rule 34 (expression -> expression * expression .)
    >               reduce using rule 34 (expression -> expression * expression .)
    <               reduce using rule 34 (expression -> expression * expression .)
    NEQ             reduce using rule 34 (expression -> expression * expression .)
    $end            reduce using rule 34 (expression -> expression * expression .)
    )               reduce using rule 34 (expression -> expression * expression .)
    }               reduce using rule 34 (expression -> expression * expression .)
    THEN            reduce using rule 34 (expression -> expression * expression .)
    DO              reduce using rule 34 (expression -> expression * expression .)
    ,               reduce using rule 34 (expression -> expression * expression .)
    ELSE            reduce using rule 34 (expression -> expression * expression .)
    END             reduce using rule 34 (expression -> expression * expression .)
    POW             shift and go to state 36

  ! POW             [ reduce using rule 34 (expression -> expression * expression .) ]
  ! ;               [ shift and go to state 31 ]
  ! +               [ shift and go to state 32 ]
  ! -               [ shift and go to state 33 ]
  ! *               [ shift and go to state 34 ]
  ! /               [ shift and go to state 35 ]
  ! EQ              [ shift and go to state 37 ]
  ! >               [ shift and go to state 38 ]
  ! <               [ shift and go to state 39 ]
  ! NEQ             [ shift and go to state 40 ]


state 61

    (35) expression -> expression / expression .
    (26) expression -> expression . ; expression
    (32) expression -> expression . + expression
    (33) expression -> expression . - expression
    (34) expression -> expression . * expression
    (35) expression -> expression . / expression
    (36) expression -> expression . POW expression
    (37) expression -> expression . EQ expression
    (38) expression -> expression . > expression
    (39) expression -> expression . < expression
    (40) expression -> expression . NEQ expression

    ;               reduce using rule 35 (expression -> expression / expression .)
    +               reduce using rule 35 (expression -> expression / expression .)
    -               reduce using rule 35 (expression -> expression / expression .)
    *               reduce using rule 35 (expression -> expression / expression .)
    /               reduce using rule 35 (expression -> expression / expression .)
    EQ              reduce using rule 35 (expression -> expression / expression .)
    >               reduce using rule 35 (expression -> expression / expression .)
    <               reduce using rule 35 (expression -> expression / expression .)
    NEQ             reduce using rule 35 (expression -> expression / expression .)
    $end            reduce using rule 35 (expression -> expression / expression .)
    )               reduce using rule 35 (expression -> expression / expression .)
    }               reduce using rule 35 (expression -> expression / expression .)
    THEN            reduce using rule 35 (expression -> expression / expression .)
    DO              reduce using rule 35 (expression -> expression / expression .)
    ,               reduce using rule 35 (expression -> expression / expression .)
    ELSE            reduce using rule 35 (expression -> expression / expression .)
    END             reduce using rule 35 (expression -> expression / expression .)
    POW             shift and go to state 36

  ! POW             [ reduce using rule 35 (expression -> expression / expression .) ]
  ! ;               [ shift and go to state 31 ]
  ! +               [ shift and go to state 32 ]
  ! -               [ shift and go to state 33 ]
  ! *               [ shift and go to state 34 ]
  ! /               [ shift and go to state 35 ]
  ! EQ              [ shift and go to state 37 ]
  ! >               [ shift and go to state 38 ]
  ! <               [ shift and go to state 39 ]
  ! NEQ             [ shift and go to state 40 ]


state 62

    (36) expression -> expression POW expression .
    (26) expression -> expression . ; expression
    (32) expression -> expression . + expression
    (33) expression -> expression . - expression
    (34) expression -> expression . * expression
    (35) expression -> expression . / expression
    (36) expression -> expression . POW expression
    (37) expression -> expression . EQ expression
    (38) expression -> expression . > expression
    (39) expression -> expression . < expression
    (40) expression -> expression . NEQ expression

    ;               reduce using rule 36 (expression -> expression POW expression .)
    +               reduce using rule 36 (expression -> expression POW expression .)
    -               reduce using rule 36 (expression -> expression POW expression .)
    *               reduce using rule 36 (expression -> expression POW expression .)
    /               reduce using rule 36 (expression -> expression POW expression .)
    EQ              reduce using rule 36 (expression -> expression POW expression .)
    >               reduce using rule 36 (expression -> expression POW expression .)
    <               reduce using rule 36 (expression -> expression POW expression .)
    NEQ             reduce using rule 36 (expression -> expression POW expression .)
    $end            reduce using rule 36 (expression -> expression POW expression .)
    )               reduce using rule 36 (expression -> expression POW expression .)
    }               reduce using rule 36 (expression -> expression POW expression .)
    THEN            reduce using rule 36 (expression -> expression POW expression .)
    DO              reduce using rule 36 (expression -> expression POW expression .)
    ,               reduce using rule 36 (expression -> expression POW expression .)
    ELSE            reduce using rule 36 (expression -> expression POW expression .)
    END             reduce using rule 36 (expression -> expression POW expression .)
    POW             shift and go to state 36

  ! POW             [ reduce using rule 36 (expression -> expression POW expression .) ]
  ! ;               [ shift and go to state 31 ]
  ! +               [ shift and go to state 32 ]
  ! -               [ shift and go to state 33 ]
  ! *               [ shift and go to state 34 ]
  ! /               [ shift and go to state 35 ]
  ! EQ              [ shift and go to state 37 ]
  ! >               [ shift and go to state 38 ]
  ! <               [ shift and go to state 39 ]
  ! NEQ             [ shift and go to state 40 ]


state 63

    (37) expression -> expression EQ expression .
    (26) expression -> expression . ; expression
    (32) expression -> expression . + expression
    (33) expression -> expression . - expression
    (34) expression -> expression . * expression
    (35) expression -> expression . / expression
    (36) expression -> expression . POW expression
    (37) expression -> expression . EQ expression
    (38) expression -> expression . > expression
    (39) expression -> expression . < expression
    (40) expression -> expression . NEQ expression

    ;               reduce using rule 37 (expression -> expression EQ expression .)
    EQ              reduce using rule 37 (expression -> expression EQ expression .)
    >               reduce using rule 37 (expression -> expression EQ expression .)
    <               reduce using rule 37 (expression -> expression EQ expression .)
    NEQ             reduce using rule 37 (expression -> expression EQ expression .)
    $end            reduce using rule 37 (expression -> expression EQ expression .)
    )               reduce using rule 37 (expression -> expression EQ expression .)
    }               reduce using rule 37 (expression -> expression EQ expression .)
    THEN            reduce using rule 37 (expression -> expression EQ expression .)
    DO              reduce using rule 37 (expression -> expression EQ expression .)
    ,               reduce using rule 37 (expression -> expression EQ expression .)
    ELSE            reduce using rule 37 (expression -> expression EQ expression .)
    END             reduce using rule 37 (expression -> expression EQ expression .)
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    POW             shift and go to state 36

  ! +               [ reduce using rule 37 (expression -> expression EQ expression .) ]
  ! -               [ reduce using rule 37 (expression -> expression EQ expression .) ]
  ! *               [ reduce using rule 37 (expression -> expression EQ expression .) ]
  ! /               [ reduce using rule 37 (expression -> expression EQ expression .) ]
  ! POW             [ reduce using rule 37 (expression -> expression EQ expression .) ]
  ! ;               [ shift and go to state 31 ]
  ! EQ              [ shift and go to state 37 ]
  ! >               [ shift and go to state 38 ]
  ! <               [ shift and go to state 39 ]
  ! NEQ             [ shift and go to state 40 ]


state 64

    (38) expression -> expression > expression .
    (26) expression -> expression . ; expression
    (32) expression -> expression . + expression
    (33) expression -> expression . - expression
    (34) expression -> expression . * expression
    (35) expression -> expression . / expression
    (36) expression -> expression . POW expression
    (37) expression -> expression . EQ expression
    (38) expression -> expression . > expression
    (39) expression -> expression . < expression
    (40) expression -> expression . NEQ expression

    ;               reduce using rule 38 (expression -> expression > expression .)
    EQ              reduce using rule 38 (expression -> expression > expression .)
    >               reduce using rule 38 (expression -> expression > expression .)
    <               reduce using rule 38 (expression -> expression > expression .)
    NEQ             reduce using rule 38 (expression -> expression > expression .)
    $end            reduce using rule 38 (expression -> expression > expression .)
    )               reduce using rule 38 (expression -> expression > expression .)
    }               reduce using rule 38 (expression -> expression > expression .)
    THEN            reduce using rule 38 (expression -> expression > expression .)
    DO              reduce using rule 38 (expression -> expression > expression .)
    ,               reduce using rule 38 (expression -> expression > expression .)
    ELSE            reduce using rule 38 (expression -> expression > expression .)
    END             reduce using rule 38 (expression -> expression > expression .)
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    POW             shift and go to state 36

  ! +               [ reduce using rule 38 (expression -> expression > expression .) ]
  ! -               [ reduce using rule 38 (expression -> expression > expression .) ]
  ! *               [ reduce using rule 38 (expression -> expression > expression .) ]
  ! /               [ reduce using rule 38 (expression -> expression > expression .) ]
  ! POW             [ reduce using rule 38 (expression -> expression > expression .) ]
  ! ;               [ shift and go to state 31 ]
  ! EQ              [ shift and go to state 37 ]
  ! >               [ shift and go to state 38 ]
  ! <               [ shift and go to state 39 ]
  ! NEQ             [ shift and go to state 40 ]


state 65

    (39) expression -> expression < expression .
    (26) expression -> expression . ; expression
    (32) expression -> expression . + expression
    (33) expression -> expression . - expression
    (34) expression -> expression . * expression
    (35) expression -> expression . / expression
    (36) expression -> expression . POW expression
    (37) expression -> expression . EQ expression
    (38) expression -> expression . > expression
    (39) expression -> expression . < expression
    (40) expression -> expression . NEQ expression

    ;               reduce using rule 39 (expression -> expression < expression .)
    EQ              reduce using rule 39 (expression -> expression < expression .)
    >               reduce using rule 39 (expression -> expression < expression .)
    <               reduce using rule 39 (expression -> expression < expression .)
    NEQ             reduce using rule 39 (expression -> expression < expression .)
    $end            reduce using rule 39 (expression -> expression < expression .)
    )               reduce using rule 39 (expression -> expression < expression .)
    }               reduce using rule 39 (expression -> expression < expression .)
    THEN            reduce using rule 39 (expression -> expression < expression .)
    DO              reduce using rule 39 (expression -> expression < expression .)
    ,               reduce using rule 39 (expression -> expression < expression .)
    ELSE            reduce using rule 39 (expression -> expression < expression .)
    END             reduce using rule 39 (expression -> expression < expression .)
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    POW             shift and go to state 36

  ! +               [ reduce using rule 39 (expression -> expression < expression .) ]
  ! -               [ reduce using rule 39 (expression -> expression < expression .) ]
  ! *               [ reduce using rule 39 (expression -> expression < expression .) ]
  ! /               [ reduce using rule 39 (expression -> expression < expression .) ]
  ! POW             [ reduce using rule 39 (expression -> expression < expression .) ]
  ! ;               [ shift and go to state 31 ]
  ! EQ              [ shift and go to state 37 ]
  ! >               [ shift and go to state 38 ]
  ! <               [ shift and go to state 39 ]
  ! NEQ             [ shift and go to state 40 ]


state 66

    (40) expression -> expression NEQ expression .
    (26) expression -> expression . ; expression
    (32) expression -> expression . + expression
    (33) expression -> expression . - expression
    (34) expression -> expression . * expression
    (35) expression -> expression . / expression
    (36) expression -> expression . POW expression
    (37) expression -> expression . EQ expression
    (38) expression -> expression . > expression
    (39) expression -> expression . < expression
    (40) expression -> expression . NEQ expression

    ;               reduce using rule 40 (expression -> expression NEQ expression .)
    EQ              reduce using rule 40 (expression -> expression NEQ expression .)
    >               reduce using rule 40 (expression -> expression NEQ expression .)
    <               reduce using rule 40 (expression -> expression NEQ expression .)
    NEQ             reduce using rule 40 (expression -> expression NEQ expression .)
    $end            reduce using rule 40 (expression -> expression NEQ expression .)
    )               reduce using rule 40 (expression -> expression NEQ expression .)
    }               reduce using rule 40 (expression -> expression NEQ expression .)
    THEN            reduce using rule 40 (expression -> expression NEQ expression .)
    DO              reduce using rule 40 (expression -> expression NEQ expression .)
    ,               reduce using rule 40 (expression -> expression NEQ expression .)
    ELSE            reduce using rule 40 (expression -> expression NEQ expression .)
    END             reduce using rule 40 (expression -> expression NEQ expression .)
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    POW             shift and go to state 36

  ! +               [ reduce using rule 40 (expression -> expression NEQ expression .) ]
  ! -               [ reduce using rule 40 (expression -> expression NEQ expression .) ]
  ! *               [ reduce using rule 40 (expression -> expression NEQ expression .) ]
  ! /               [ reduce using rule 40 (expression -> expression NEQ expression .) ]
  ! POW             [ reduce using rule 40 (expression -> expression NEQ expression .) ]
  ! ;               [ shift and go to state 31 ]
  ! EQ              [ shift and go to state 37 ]
  ! >               [ shift and go to state 38 ]
  ! <               [ shift and go to state 39 ]
  ! NEQ             [ shift and go to state 40 ]


state 67

    (18) statement -> DEF NAME args . - > type = expression

    -               shift and go to state 80


state 68

    (20) args -> type . NAME args

    NAME            shift and go to state 81


state 69

    (19) args -> empty .

    -               reduce using rule 19 (args -> empty .)


state 70

    (12) expression -> NAME = expression .
    (26) expression -> expression . ; expression
    (32) expression -> expression . + expression
    (33) expression -> expression . - expression
    (34) expression -> expression . * expression
    (35) expression -> expression . / expression
    (36) expression -> expression . POW expression
    (37) expression -> expression . EQ expression
    (38) expression -> expression . > expression
    (39) expression -> expression . < expression
    (40) expression -> expression . NEQ expression

    ;               reduce using rule 12 (expression -> NAME = expression .)
    EQ              reduce using rule 12 (expression -> NAME = expression .)
    >               reduce using rule 12 (expression -> NAME = expression .)
    <               reduce using rule 12 (expression -> NAME = expression .)
    NEQ             reduce using rule 12 (expression -> NAME = expression .)
    $end            reduce using rule 12 (expression -> NAME = expression .)
    )               reduce using rule 12 (expression -> NAME = expression .)
    }               reduce using rule 12 (expression -> NAME = expression .)
    THEN            reduce using rule 12 (expression -> NAME = expression .)
    DO              reduce using rule 12 (expression -> NAME = expression .)
    ,               reduce using rule 12 (expression -> NAME = expression .)
    ELSE            reduce using rule 12 (expression -> NAME = expression .)
    END             reduce using rule 12 (expression -> NAME = expression .)
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    POW             shift and go to state 36

  ! +               [ reduce using rule 12 (expression -> NAME = expression .) ]
  ! -               [ reduce using rule 12 (expression -> NAME = expression .) ]
  ! *               [ reduce using rule 12 (expression -> NAME = expression .) ]
  ! /               [ reduce using rule 12 (expression -> NAME = expression .) ]
  ! POW             [ reduce using rule 12 (expression -> NAME = expression .) ]
  ! ;               [ shift and go to state 31 ]
  ! EQ              [ shift and go to state 37 ]
  ! >               [ shift and go to state 38 ]
  ! <               [ shift and go to state 39 ]
  ! NEQ             [ shift and go to state 40 ]


state 71

    (21) expression -> NAME ( call_args . )

    )               shift and go to state 82


state 72

    (22) call_args -> empty .

    )               reduce using rule 22 (call_args -> empty .)


state 73

    (23) call_args -> expression .
    (24) call_args -> expression . , call_args
    (26) expression -> expression . ; expression
    (32) expression -> expression . + expression
    (33) expression -> expression . - expression
    (34) expression -> expression . * expression
    (35) expression -> expression . / expression
    (36) expression -> expression . POW expression
    (37) expression -> expression . EQ expression
    (38) expression -> expression . > expression
    (39) expression -> expression . < expression
    (40) expression -> expression . NEQ expression

    )               reduce using rule 23 (call_args -> expression .)
    ,               shift and go to state 83
    ;               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    POW             shift and go to state 36
    EQ              shift and go to state 37
    >               shift and go to state 38
    <               shift and go to state 39
    NEQ             shift and go to state 40


state 74

    (17) expression -> type NAME = . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    type                           shift and go to state 6
    expression                     shift and go to state 84
    convert                        shift and go to state 7

state 75

    (42) expression -> ( expression ) .

    ;               reduce using rule 42 (expression -> ( expression ) .)
    +               reduce using rule 42 (expression -> ( expression ) .)
    -               reduce using rule 42 (expression -> ( expression ) .)
    *               reduce using rule 42 (expression -> ( expression ) .)
    /               reduce using rule 42 (expression -> ( expression ) .)
    POW             reduce using rule 42 (expression -> ( expression ) .)
    EQ              reduce using rule 42 (expression -> ( expression ) .)
    >               reduce using rule 42 (expression -> ( expression ) .)
    <               reduce using rule 42 (expression -> ( expression ) .)
    NEQ             reduce using rule 42 (expression -> ( expression ) .)
    $end            reduce using rule 42 (expression -> ( expression ) .)
    )               reduce using rule 42 (expression -> ( expression ) .)
    }               reduce using rule 42 (expression -> ( expression ) .)
    THEN            reduce using rule 42 (expression -> ( expression ) .)
    DO              reduce using rule 42 (expression -> ( expression ) .)
    ,               reduce using rule 42 (expression -> ( expression ) .)
    ELSE            reduce using rule 42 (expression -> ( expression ) .)
    END             reduce using rule 42 (expression -> ( expression ) .)


state 76

    (25) expression -> error ; expression .
    (26) expression -> expression . ; expression
    (32) expression -> expression . + expression
    (33) expression -> expression . - expression
    (34) expression -> expression . * expression
    (35) expression -> expression . / expression
    (36) expression -> expression . POW expression
    (37) expression -> expression . EQ expression
    (38) expression -> expression . > expression
    (39) expression -> expression . < expression
    (40) expression -> expression . NEQ expression

    ;               reduce using rule 25 (expression -> error ; expression .)
    $end            reduce using rule 25 (expression -> error ; expression .)
    )               reduce using rule 25 (expression -> error ; expression .)
    }               reduce using rule 25 (expression -> error ; expression .)
    THEN            reduce using rule 25 (expression -> error ; expression .)
    DO              reduce using rule 25 (expression -> error ; expression .)
    ,               reduce using rule 25 (expression -> error ; expression .)
    ELSE            reduce using rule 25 (expression -> error ; expression .)
    END             reduce using rule 25 (expression -> error ; expression .)
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    POW             shift and go to state 36
    EQ              shift and go to state 37
    >               shift and go to state 38
    <               shift and go to state 39
    NEQ             shift and go to state 40

  ! +               [ reduce using rule 25 (expression -> error ; expression .) ]
  ! -               [ reduce using rule 25 (expression -> error ; expression .) ]
  ! *               [ reduce using rule 25 (expression -> error ; expression .) ]
  ! /               [ reduce using rule 25 (expression -> error ; expression .) ]
  ! POW             [ reduce using rule 25 (expression -> error ; expression .) ]
  ! EQ              [ reduce using rule 25 (expression -> error ; expression .) ]
  ! >               [ reduce using rule 25 (expression -> error ; expression .) ]
  ! <               [ reduce using rule 25 (expression -> error ; expression .) ]
  ! NEQ             [ reduce using rule 25 (expression -> error ; expression .) ]
  ! ;               [ shift and go to state 31 ]


state 77

    (27) expression -> { expression } .

    ;               reduce using rule 27 (expression -> { expression } .)
    +               reduce using rule 27 (expression -> { expression } .)
    -               reduce using rule 27 (expression -> { expression } .)
    *               reduce using rule 27 (expression -> { expression } .)
    /               reduce using rule 27 (expression -> { expression } .)
    POW             reduce using rule 27 (expression -> { expression } .)
    EQ              reduce using rule 27 (expression -> { expression } .)
    >               reduce using rule 27 (expression -> { expression } .)
    <               reduce using rule 27 (expression -> { expression } .)
    NEQ             reduce using rule 27 (expression -> { expression } .)
    $end            reduce using rule 27 (expression -> { expression } .)
    )               reduce using rule 27 (expression -> { expression } .)
    }               reduce using rule 27 (expression -> { expression } .)
    THEN            reduce using rule 27 (expression -> { expression } .)
    DO              reduce using rule 27 (expression -> { expression } .)
    ,               reduce using rule 27 (expression -> { expression } .)
    ELSE            reduce using rule 27 (expression -> { expression } .)
    END             reduce using rule 27 (expression -> { expression } .)


state 78

    (28) expression -> IF expression THEN . expression else_expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    expression                     shift and go to state 85
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 79

    (31) expression -> WHILE expression DO . expression END
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    expression                     shift and go to state 86
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 80

    (18) statement -> DEF NAME args - . > type = expression

    >               shift and go to state 87


state 81

    (20) args -> type NAME . args
    (19) args -> . empty
    (20) args -> . type NAME args
    (49) empty -> .
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    -               reduce using rule 49 (empty -> .)
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    type                           shift and go to state 68
    args                           shift and go to state 88
    empty                          shift and go to state 69

state 82

    (21) expression -> NAME ( call_args ) .

    ;               reduce using rule 21 (expression -> NAME ( call_args ) .)
    +               reduce using rule 21 (expression -> NAME ( call_args ) .)
    -               reduce using rule 21 (expression -> NAME ( call_args ) .)
    *               reduce using rule 21 (expression -> NAME ( call_args ) .)
    /               reduce using rule 21 (expression -> NAME ( call_args ) .)
    POW             reduce using rule 21 (expression -> NAME ( call_args ) .)
    EQ              reduce using rule 21 (expression -> NAME ( call_args ) .)
    >               reduce using rule 21 (expression -> NAME ( call_args ) .)
    <               reduce using rule 21 (expression -> NAME ( call_args ) .)
    NEQ             reduce using rule 21 (expression -> NAME ( call_args ) .)
    $end            reduce using rule 21 (expression -> NAME ( call_args ) .)
    )               reduce using rule 21 (expression -> NAME ( call_args ) .)
    }               reduce using rule 21 (expression -> NAME ( call_args ) .)
    THEN            reduce using rule 21 (expression -> NAME ( call_args ) .)
    DO              reduce using rule 21 (expression -> NAME ( call_args ) .)
    ,               reduce using rule 21 (expression -> NAME ( call_args ) .)
    ELSE            reduce using rule 21 (expression -> NAME ( call_args ) .)
    END             reduce using rule 21 (expression -> NAME ( call_args ) .)


state 83

    (24) call_args -> expression , . call_args
    (22) call_args -> . empty
    (23) call_args -> . expression
    (24) call_args -> . expression , call_args
    (49) empty -> .
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    )               reduce using rule 49 (empty -> .)
    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    expression                     shift and go to state 73
    call_args                      shift and go to state 89
    empty                          shift and go to state 72
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 84

    (17) expression -> type NAME = expression .
    (26) expression -> expression . ; expression
    (32) expression -> expression . + expression
    (33) expression -> expression . - expression
    (34) expression -> expression . * expression
    (35) expression -> expression . / expression
    (36) expression -> expression . POW expression
    (37) expression -> expression . EQ expression
    (38) expression -> expression . > expression
    (39) expression -> expression . < expression
    (40) expression -> expression . NEQ expression

    ;               reduce using rule 17 (expression -> type NAME = expression .)
    EQ              reduce using rule 17 (expression -> type NAME = expression .)
    >               reduce using rule 17 (expression -> type NAME = expression .)
    <               reduce using rule 17 (expression -> type NAME = expression .)
    NEQ             reduce using rule 17 (expression -> type NAME = expression .)
    $end            reduce using rule 17 (expression -> type NAME = expression .)
    )               reduce using rule 17 (expression -> type NAME = expression .)
    }               reduce using rule 17 (expression -> type NAME = expression .)
    THEN            reduce using rule 17 (expression -> type NAME = expression .)
    DO              reduce using rule 17 (expression -> type NAME = expression .)
    ,               reduce using rule 17 (expression -> type NAME = expression .)
    ELSE            reduce using rule 17 (expression -> type NAME = expression .)
    END             reduce using rule 17 (expression -> type NAME = expression .)
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    POW             shift and go to state 36

  ! +               [ reduce using rule 17 (expression -> type NAME = expression .) ]
  ! -               [ reduce using rule 17 (expression -> type NAME = expression .) ]
  ! *               [ reduce using rule 17 (expression -> type NAME = expression .) ]
  ! /               [ reduce using rule 17 (expression -> type NAME = expression .) ]
  ! POW             [ reduce using rule 17 (expression -> type NAME = expression .) ]
  ! ;               [ shift and go to state 31 ]
  ! EQ              [ shift and go to state 37 ]
  ! >               [ shift and go to state 38 ]
  ! <               [ shift and go to state 39 ]
  ! NEQ             [ shift and go to state 40 ]


state 85

    (28) expression -> IF expression THEN expression . else_expression
    (26) expression -> expression . ; expression
    (32) expression -> expression . + expression
    (33) expression -> expression . - expression
    (34) expression -> expression . * expression
    (35) expression -> expression . / expression
    (36) expression -> expression . POW expression
    (37) expression -> expression . EQ expression
    (38) expression -> expression . > expression
    (39) expression -> expression . < expression
    (40) expression -> expression . NEQ expression
    (29) else_expression -> . ELSE expression
    (30) else_expression -> . empty
    (49) empty -> .

  ! shift/reduce conflict for ; resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for POW resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
    ;               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    POW             shift and go to state 36
    EQ              shift and go to state 37
    >               shift and go to state 38
    <               shift and go to state 39
    NEQ             shift and go to state 40
    ELSE            shift and go to state 91
    $end            reduce using rule 49 (empty -> .)
    )               reduce using rule 49 (empty -> .)
    }               reduce using rule 49 (empty -> .)
    THEN            reduce using rule 49 (empty -> .)
    DO              reduce using rule 49 (empty -> .)
    ,               reduce using rule 49 (empty -> .)
    END             reduce using rule 49 (empty -> .)

  ! ;               [ reduce using rule 49 (empty -> .) ]
  ! +               [ reduce using rule 49 (empty -> .) ]
  ! -               [ reduce using rule 49 (empty -> .) ]
  ! *               [ reduce using rule 49 (empty -> .) ]
  ! /               [ reduce using rule 49 (empty -> .) ]
  ! POW             [ reduce using rule 49 (empty -> .) ]
  ! EQ              [ reduce using rule 49 (empty -> .) ]
  ! >               [ reduce using rule 49 (empty -> .) ]
  ! <               [ reduce using rule 49 (empty -> .) ]
  ! NEQ             [ reduce using rule 49 (empty -> .) ]
  ! ELSE            [ reduce using rule 49 (empty -> .) ]

    else_expression                shift and go to state 90
    empty                          shift and go to state 92

state 86

    (31) expression -> WHILE expression DO expression . END
    (26) expression -> expression . ; expression
    (32) expression -> expression . + expression
    (33) expression -> expression . - expression
    (34) expression -> expression . * expression
    (35) expression -> expression . / expression
    (36) expression -> expression . POW expression
    (37) expression -> expression . EQ expression
    (38) expression -> expression . > expression
    (39) expression -> expression . < expression
    (40) expression -> expression . NEQ expression

    END             shift and go to state 93
    ;               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    POW             shift and go to state 36
    EQ              shift and go to state 37
    >               shift and go to state 38
    <               shift and go to state 39
    NEQ             shift and go to state 40


state 87

    (18) statement -> DEF NAME args - > . type = expression
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    type                           shift and go to state 94

state 88

    (20) args -> type NAME args .

    -               reduce using rule 20 (args -> type NAME args .)


state 89

    (24) call_args -> expression , call_args .

    )               reduce using rule 24 (call_args -> expression , call_args .)


state 90

    (28) expression -> IF expression THEN expression else_expression .

    ;               reduce using rule 28 (expression -> IF expression THEN expression else_expression .)
    +               reduce using rule 28 (expression -> IF expression THEN expression else_expression .)
    -               reduce using rule 28 (expression -> IF expression THEN expression else_expression .)
    *               reduce using rule 28 (expression -> IF expression THEN expression else_expression .)
    /               reduce using rule 28 (expression -> IF expression THEN expression else_expression .)
    POW             reduce using rule 28 (expression -> IF expression THEN expression else_expression .)
    EQ              reduce using rule 28 (expression -> IF expression THEN expression else_expression .)
    >               reduce using rule 28 (expression -> IF expression THEN expression else_expression .)
    <               reduce using rule 28 (expression -> IF expression THEN expression else_expression .)
    NEQ             reduce using rule 28 (expression -> IF expression THEN expression else_expression .)
    $end            reduce using rule 28 (expression -> IF expression THEN expression else_expression .)
    )               reduce using rule 28 (expression -> IF expression THEN expression else_expression .)
    }               reduce using rule 28 (expression -> IF expression THEN expression else_expression .)
    THEN            reduce using rule 28 (expression -> IF expression THEN expression else_expression .)
    DO              reduce using rule 28 (expression -> IF expression THEN expression else_expression .)
    ,               reduce using rule 28 (expression -> IF expression THEN expression else_expression .)
    ELSE            reduce using rule 28 (expression -> IF expression THEN expression else_expression .)
    END             reduce using rule 28 (expression -> IF expression THEN expression else_expression .)


state 91

    (29) else_expression -> ELSE . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    expression                     shift and go to state 95
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 92

    (30) else_expression -> empty .

    ;               reduce using rule 30 (else_expression -> empty .)
    +               reduce using rule 30 (else_expression -> empty .)
    -               reduce using rule 30 (else_expression -> empty .)
    *               reduce using rule 30 (else_expression -> empty .)
    /               reduce using rule 30 (else_expression -> empty .)
    POW             reduce using rule 30 (else_expression -> empty .)
    EQ              reduce using rule 30 (else_expression -> empty .)
    >               reduce using rule 30 (else_expression -> empty .)
    <               reduce using rule 30 (else_expression -> empty .)
    NEQ             reduce using rule 30 (else_expression -> empty .)
    $end            reduce using rule 30 (else_expression -> empty .)
    )               reduce using rule 30 (else_expression -> empty .)
    }               reduce using rule 30 (else_expression -> empty .)
    THEN            reduce using rule 30 (else_expression -> empty .)
    DO              reduce using rule 30 (else_expression -> empty .)
    ,               reduce using rule 30 (else_expression -> empty .)
    ELSE            reduce using rule 30 (else_expression -> empty .)
    END             reduce using rule 30 (else_expression -> empty .)


state 93

    (31) expression -> WHILE expression DO expression END .

    ;               reduce using rule 31 (expression -> WHILE expression DO expression END .)
    +               reduce using rule 31 (expression -> WHILE expression DO expression END .)
    -               reduce using rule 31 (expression -> WHILE expression DO expression END .)
    *               reduce using rule 31 (expression -> WHILE expression DO expression END .)
    /               reduce using rule 31 (expression -> WHILE expression DO expression END .)
    POW             reduce using rule 31 (expression -> WHILE expression DO expression END .)
    EQ              reduce using rule 31 (expression -> WHILE expression DO expression END .)
    >               reduce using rule 31 (expression -> WHILE expression DO expression END .)
    <               reduce using rule 31 (expression -> WHILE expression DO expression END .)
    NEQ             reduce using rule 31 (expression -> WHILE expression DO expression END .)
    $end            reduce using rule 31 (expression -> WHILE expression DO expression END .)
    )               reduce using rule 31 (expression -> WHILE expression DO expression END .)
    }               reduce using rule 31 (expression -> WHILE expression DO expression END .)
    THEN            reduce using rule 31 (expression -> WHILE expression DO expression END .)
    DO              reduce using rule 31 (expression -> WHILE expression DO expression END .)
    ,               reduce using rule 31 (expression -> WHILE expression DO expression END .)
    ELSE            reduce using rule 31 (expression -> WHILE expression DO expression END .)
    END             reduce using rule 31 (expression -> WHILE expression DO expression END .)


state 94

    (18) statement -> DEF NAME args - > type . = expression

    =               shift and go to state 96


state 95

    (29) else_expression -> ELSE expression .
    (26) expression -> expression . ; expression
    (32) expression -> expression . + expression
    (33) expression -> expression . - expression
    (34) expression -> expression . * expression
    (35) expression -> expression . / expression
    (36) expression -> expression . POW expression
    (37) expression -> expression . EQ expression
    (38) expression -> expression . > expression
    (39) expression -> expression . < expression
    (40) expression -> expression . NEQ expression

    $end            reduce using rule 29 (else_expression -> ELSE expression .)
    )               reduce using rule 29 (else_expression -> ELSE expression .)
    }               reduce using rule 29 (else_expression -> ELSE expression .)
    THEN            reduce using rule 29 (else_expression -> ELSE expression .)
    DO              reduce using rule 29 (else_expression -> ELSE expression .)
    ,               reduce using rule 29 (else_expression -> ELSE expression .)
    ELSE            reduce using rule 29 (else_expression -> ELSE expression .)
    END             reduce using rule 29 (else_expression -> ELSE expression .)
    ;               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    POW             shift and go to state 36
    EQ              shift and go to state 37
    >               shift and go to state 38
    <               shift and go to state 39
    NEQ             shift and go to state 40

  ! ;               [ reduce using rule 29 (else_expression -> ELSE expression .) ]
  ! +               [ reduce using rule 29 (else_expression -> ELSE expression .) ]
  ! -               [ reduce using rule 29 (else_expression -> ELSE expression .) ]
  ! *               [ reduce using rule 29 (else_expression -> ELSE expression .) ]
  ! /               [ reduce using rule 29 (else_expression -> ELSE expression .) ]
  ! POW             [ reduce using rule 29 (else_expression -> ELSE expression .) ]
  ! EQ              [ reduce using rule 29 (else_expression -> ELSE expression .) ]
  ! >               [ reduce using rule 29 (else_expression -> ELSE expression .) ]
  ! <               [ reduce using rule 29 (else_expression -> ELSE expression .) ]
  ! NEQ             [ reduce using rule 29 (else_expression -> ELSE expression .) ]


state 96

    (18) statement -> DEF NAME args - > type = . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . SIN expression
    (11) expression -> . COS expression
    (12) expression -> . NAME = expression
    (17) expression -> . type NAME = expression
    (21) expression -> . NAME ( call_args )
    (25) expression -> . error ; expression
    (26) expression -> . expression ; expression
    (27) expression -> . { expression }
    (28) expression -> . IF expression THEN expression else_expression
    (31) expression -> . WHILE expression DO expression END
    (32) expression -> . expression + expression
    (33) expression -> . expression - expression
    (34) expression -> . expression * expression
    (35) expression -> . expression / expression
    (36) expression -> . expression POW expression
    (37) expression -> . expression EQ expression
    (38) expression -> . expression > expression
    (39) expression -> . expression < expression
    (40) expression -> . expression NEQ expression
    (41) expression -> . - expression
    (42) expression -> . ( expression )
    (43) expression -> . NUMBER
    (44) expression -> . FLOAT
    (45) expression -> . STRING
    (46) expression -> . TRUE
    (47) expression -> . FALSE
    (48) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (13) type -> . STRING_TYPE
    (14) type -> . INT_TYPE
    (15) type -> . FLOAT_TYPE
    (16) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    SIN             shift and go to state 10
    COS             shift and go to state 11
    NAME            shift and go to state 4
    error           shift and go to state 13
    {               shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    -               shift and go to state 5
    (               shift and go to state 12
    NUMBER          shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    2INT            shift and go to state 22
    2STR            shift and go to state 23
    2FLOAT          shift and go to state 24
    2BOOL           shift and go to state 25
    STRING_TYPE     shift and go to state 26
    INT_TYPE        shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    BOOL_TYPE       shift and go to state 29

    type                           shift and go to state 6
    expression                     shift and go to state 97
    convert                        shift and go to state 7

state 97

    (18) statement -> DEF NAME args - > type = expression .
    (26) expression -> expression . ; expression
    (32) expression -> expression . + expression
    (33) expression -> expression . - expression
    (34) expression -> expression . * expression
    (35) expression -> expression . / expression
    (36) expression -> expression . POW expression
    (37) expression -> expression . EQ expression
    (38) expression -> expression . > expression
    (39) expression -> expression . < expression
    (40) expression -> expression . NEQ expression

    ;               reduce using rule 18 (statement -> DEF NAME args - > type = expression .)
    $end            reduce using rule 18 (statement -> DEF NAME args - > type = expression .)
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    POW             shift and go to state 36
    EQ              shift and go to state 37
    >               shift and go to state 38
    <               shift and go to state 39
    NEQ             shift and go to state 40

  ! ;               [ shift and go to state 31 ]

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ; in state 2 resolved as shift
WARNING: shift/reduce conflict for ; in state 46 resolved as shift
WARNING: shift/reduce conflict for + in state 46 resolved as shift
WARNING: shift/reduce conflict for - in state 46 resolved as shift
WARNING: shift/reduce conflict for * in state 46 resolved as shift
WARNING: shift/reduce conflict for / in state 46 resolved as shift
WARNING: shift/reduce conflict for POW in state 46 resolved as shift
WARNING: shift/reduce conflict for EQ in state 46 resolved as shift
WARNING: shift/reduce conflict for > in state 46 resolved as shift
WARNING: shift/reduce conflict for < in state 46 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 46 resolved as shift
WARNING: shift/reduce conflict for ; in state 85 resolved as shift
WARNING: shift/reduce conflict for + in state 85 resolved as shift
WARNING: shift/reduce conflict for - in state 85 resolved as shift
WARNING: shift/reduce conflict for * in state 85 resolved as shift
WARNING: shift/reduce conflict for / in state 85 resolved as shift
WARNING: shift/reduce conflict for POW in state 85 resolved as shift
WARNING: shift/reduce conflict for EQ in state 85 resolved as shift
WARNING: shift/reduce conflict for > in state 85 resolved as shift
WARNING: shift/reduce conflict for < in state 85 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 85 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 85 resolved as shift
