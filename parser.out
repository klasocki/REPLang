Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> statement
Rule 1     statement -> expression
Rule 2     statement -> statement ; statement
Rule 3     convert -> 2INT
Rule 4     convert -> 2STR
Rule 5     convert -> 2FLOAT
Rule 6     convert -> 2BOOL
Rule 7     expression -> convert expression
Rule 8     expression -> NOT expression
Rule 9     expression -> PRINT expression
Rule 10    expression -> NAME = expression
Rule 11    type -> STRING_TYPE
Rule 12    type -> INT_TYPE
Rule 13    type -> FLOAT_TYPE
Rule 14    type -> BOOL_TYPE
Rule 15    expression -> type NAME = expression
Rule 16    statement -> DEF NAME args - > type = expression
Rule 17    args -> empty
Rule 18    args -> type NAME args
Rule 19    expression -> NAME ( call_args )
Rule 20    call_args -> empty
Rule 21    call_args -> expression
Rule 22    call_args -> expression , call_args
Rule 23    expression -> error ; expression
Rule 24    expression -> expression ; expression
Rule 25    expression -> { expression }
Rule 26    expression -> IF expression THEN expression else_expression
Rule 27    else_expression -> ELSE expression
Rule 28    else_expression -> empty
Rule 29    expression -> WHILE expression DO expression END
Rule 30    expression -> expression + expression
Rule 31    expression -> expression - expression
Rule 32    expression -> expression * expression
Rule 33    expression -> expression / expression
Rule 34    expression -> expression ^ expression
Rule 35    expression -> expression EQ expression
Rule 36    expression -> expression > expression
Rule 37    expression -> expression < expression
Rule 38    expression -> expression NEQ expression
Rule 39    expression -> - expression
Rule 40    expression -> ( expression )
Rule 41    expression -> NUMBER
Rule 42    expression -> FLOAT
Rule 43    expression -> STRING
Rule 44    expression -> TRUE
Rule 45    expression -> FALSE
Rule 46    expression -> NAME
Rule 47    empty -> <empty>

Terminals, with rules where they appear

(                    : 19 40
)                    : 19 40
*                    : 32
+                    : 30
,                    : 22
-                    : 16 31 39
/                    : 33
2BOOL                : 6
2FLOAT               : 5
2INT                 : 3
2STR                 : 4
;                    : 2 23 24
<                    : 37
=                    : 10 15 16
>                    : 16 36
BOOL_TYPE            : 14
DEF                  : 16
DO                   : 29
ELSE                 : 27
END                  : 29
EQ                   : 35
FALSE                : 45
FLOAT                : 42
FLOAT_TYPE           : 13
IF                   : 26
INT_TYPE             : 12
NAME                 : 10 15 16 18 19 46
NEQ                  : 38
NOT                  : 8
NUMBER               : 41
PRINT                : 9
STRING               : 43
STRING_TYPE          : 11
THEN                 : 26
TRUE                 : 44
WHILE                : 29
^                    : 34
error                : 23
{                    : 25
}                    : 25

Nonterminals, with rules where they appear

args                 : 16 18
call_args            : 19 22
convert              : 7
else_expression      : 26
empty                : 17 20 28
expression           : 1 7 8 9 10 15 16 21 22 23 24 24 25 26 26 27 29 29 30 30 31 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 40
statement            : 2 2 0
type                 : 15 16 18

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . expression
    (2) statement -> . statement ; statement
    (16) statement -> . DEF NAME args - > type = expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . NAME = expression
    (15) expression -> . type NAME = expression
    (19) expression -> . NAME ( call_args )
    (23) expression -> . error ; expression
    (24) expression -> . expression ; expression
    (25) expression -> . { expression }
    (26) expression -> . IF expression THEN expression else_expression
    (29) expression -> . WHILE expression DO expression END
    (30) expression -> . expression + expression
    (31) expression -> . expression - expression
    (32) expression -> . expression * expression
    (33) expression -> . expression / expression
    (34) expression -> . expression ^ expression
    (35) expression -> . expression EQ expression
    (36) expression -> . expression > expression
    (37) expression -> . expression < expression
    (38) expression -> . expression NEQ expression
    (39) expression -> . - expression
    (40) expression -> . ( expression )
    (41) expression -> . NUMBER
    (42) expression -> . FLOAT
    (43) expression -> . STRING
    (44) expression -> . TRUE
    (45) expression -> . FALSE
    (46) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    DEF             shift and go to state 3
    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    NAME            shift and go to state 4
    error           shift and go to state 11
    {               shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    -               shift and go to state 5
    (               shift and go to state 10
    NUMBER          shift and go to state 15
    FLOAT           shift and go to state 16
    STRING          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    2INT            shift and go to state 20
    2STR            shift and go to state 21
    2FLOAT          shift and go to state 22
    2BOOL           shift and go to state 23
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    statement                      shift and go to state 1
    expression                     shift and go to state 2
    type                           shift and go to state 6
    convert                        shift and go to state 7

state 1

    (0) S' -> statement .
    (2) statement -> statement . ; statement

    ;               shift and go to state 28


state 2

    (1) statement -> expression .
    (24) expression -> expression . ; expression
    (30) expression -> expression . + expression
    (31) expression -> expression . - expression
    (32) expression -> expression . * expression
    (33) expression -> expression . / expression
    (34) expression -> expression . ^ expression
    (35) expression -> expression . EQ expression
    (36) expression -> expression . > expression
    (37) expression -> expression . < expression
    (38) expression -> expression . NEQ expression

  ! shift/reduce conflict for ; resolved as shift
    $end            reduce using rule 1 (statement -> expression .)
    ;               shift and go to state 29
    +               shift and go to state 30
    -               shift and go to state 31
    *               shift and go to state 32
    /               shift and go to state 33
    ^               shift and go to state 34
    EQ              shift and go to state 35
    >               shift and go to state 36
    <               shift and go to state 37
    NEQ             shift and go to state 38

  ! ;               [ reduce using rule 1 (statement -> expression .) ]


state 3

    (16) statement -> DEF . NAME args - > type = expression

    NAME            shift and go to state 39


state 4

    (10) expression -> NAME . = expression
    (19) expression -> NAME . ( call_args )
    (46) expression -> NAME .

    =               shift and go to state 40
    (               shift and go to state 41
    ;               reduce using rule 46 (expression -> NAME .)
    +               reduce using rule 46 (expression -> NAME .)
    -               reduce using rule 46 (expression -> NAME .)
    *               reduce using rule 46 (expression -> NAME .)
    /               reduce using rule 46 (expression -> NAME .)
    ^               reduce using rule 46 (expression -> NAME .)
    EQ              reduce using rule 46 (expression -> NAME .)
    >               reduce using rule 46 (expression -> NAME .)
    <               reduce using rule 46 (expression -> NAME .)
    NEQ             reduce using rule 46 (expression -> NAME .)
    $end            reduce using rule 46 (expression -> NAME .)
    )               reduce using rule 46 (expression -> NAME .)
    }               reduce using rule 46 (expression -> NAME .)
    THEN            reduce using rule 46 (expression -> NAME .)
    DO              reduce using rule 46 (expression -> NAME .)
    ,               reduce using rule 46 (expression -> NAME .)
    ELSE            reduce using rule 46 (expression -> NAME .)
    END             reduce using rule 46 (expression -> NAME .)


state 5

    (39) expression -> - . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . NAME = expression
    (15) expression -> . type NAME = expression
    (19) expression -> . NAME ( call_args )
    (23) expression -> . error ; expression
    (24) expression -> . expression ; expression
    (25) expression -> . { expression }
    (26) expression -> . IF expression THEN expression else_expression
    (29) expression -> . WHILE expression DO expression END
    (30) expression -> . expression + expression
    (31) expression -> . expression - expression
    (32) expression -> . expression * expression
    (33) expression -> . expression / expression
    (34) expression -> . expression ^ expression
    (35) expression -> . expression EQ expression
    (36) expression -> . expression > expression
    (37) expression -> . expression < expression
    (38) expression -> . expression NEQ expression
    (39) expression -> . - expression
    (40) expression -> . ( expression )
    (41) expression -> . NUMBER
    (42) expression -> . FLOAT
    (43) expression -> . STRING
    (44) expression -> . TRUE
    (45) expression -> . FALSE
    (46) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    NAME            shift and go to state 4
    error           shift and go to state 11
    {               shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    -               shift and go to state 5
    (               shift and go to state 10
    NUMBER          shift and go to state 15
    FLOAT           shift and go to state 16
    STRING          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    2INT            shift and go to state 20
    2STR            shift and go to state 21
    2FLOAT          shift and go to state 22
    2BOOL           shift and go to state 23
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    expression                     shift and go to state 42
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 6

    (15) expression -> type . NAME = expression

    NAME            shift and go to state 43


state 7

    (7) expression -> convert . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . NAME = expression
    (15) expression -> . type NAME = expression
    (19) expression -> . NAME ( call_args )
    (23) expression -> . error ; expression
    (24) expression -> . expression ; expression
    (25) expression -> . { expression }
    (26) expression -> . IF expression THEN expression else_expression
    (29) expression -> . WHILE expression DO expression END
    (30) expression -> . expression + expression
    (31) expression -> . expression - expression
    (32) expression -> . expression * expression
    (33) expression -> . expression / expression
    (34) expression -> . expression ^ expression
    (35) expression -> . expression EQ expression
    (36) expression -> . expression > expression
    (37) expression -> . expression < expression
    (38) expression -> . expression NEQ expression
    (39) expression -> . - expression
    (40) expression -> . ( expression )
    (41) expression -> . NUMBER
    (42) expression -> . FLOAT
    (43) expression -> . STRING
    (44) expression -> . TRUE
    (45) expression -> . FALSE
    (46) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    NAME            shift and go to state 4
    error           shift and go to state 11
    {               shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    -               shift and go to state 5
    (               shift and go to state 10
    NUMBER          shift and go to state 15
    FLOAT           shift and go to state 16
    STRING          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    2INT            shift and go to state 20
    2STR            shift and go to state 21
    2FLOAT          shift and go to state 22
    2BOOL           shift and go to state 23
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    convert                        shift and go to state 7
    expression                     shift and go to state 44
    type                           shift and go to state 6

state 8

    (8) expression -> NOT . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . NAME = expression
    (15) expression -> . type NAME = expression
    (19) expression -> . NAME ( call_args )
    (23) expression -> . error ; expression
    (24) expression -> . expression ; expression
    (25) expression -> . { expression }
    (26) expression -> . IF expression THEN expression else_expression
    (29) expression -> . WHILE expression DO expression END
    (30) expression -> . expression + expression
    (31) expression -> . expression - expression
    (32) expression -> . expression * expression
    (33) expression -> . expression / expression
    (34) expression -> . expression ^ expression
    (35) expression -> . expression EQ expression
    (36) expression -> . expression > expression
    (37) expression -> . expression < expression
    (38) expression -> . expression NEQ expression
    (39) expression -> . - expression
    (40) expression -> . ( expression )
    (41) expression -> . NUMBER
    (42) expression -> . FLOAT
    (43) expression -> . STRING
    (44) expression -> . TRUE
    (45) expression -> . FALSE
    (46) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    NAME            shift and go to state 4
    error           shift and go to state 11
    {               shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    -               shift and go to state 5
    (               shift and go to state 10
    NUMBER          shift and go to state 15
    FLOAT           shift and go to state 16
    STRING          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    2INT            shift and go to state 20
    2STR            shift and go to state 21
    2FLOAT          shift and go to state 22
    2BOOL           shift and go to state 23
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    expression                     shift and go to state 45
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 9

    (9) expression -> PRINT . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . NAME = expression
    (15) expression -> . type NAME = expression
    (19) expression -> . NAME ( call_args )
    (23) expression -> . error ; expression
    (24) expression -> . expression ; expression
    (25) expression -> . { expression }
    (26) expression -> . IF expression THEN expression else_expression
    (29) expression -> . WHILE expression DO expression END
    (30) expression -> . expression + expression
    (31) expression -> . expression - expression
    (32) expression -> . expression * expression
    (33) expression -> . expression / expression
    (34) expression -> . expression ^ expression
    (35) expression -> . expression EQ expression
    (36) expression -> . expression > expression
    (37) expression -> . expression < expression
    (38) expression -> . expression NEQ expression
    (39) expression -> . - expression
    (40) expression -> . ( expression )
    (41) expression -> . NUMBER
    (42) expression -> . FLOAT
    (43) expression -> . STRING
    (44) expression -> . TRUE
    (45) expression -> . FALSE
    (46) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    NAME            shift and go to state 4
    error           shift and go to state 11
    {               shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    -               shift and go to state 5
    (               shift and go to state 10
    NUMBER          shift and go to state 15
    FLOAT           shift and go to state 16
    STRING          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    2INT            shift and go to state 20
    2STR            shift and go to state 21
    2FLOAT          shift and go to state 22
    2BOOL           shift and go to state 23
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    expression                     shift and go to state 46
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 10

    (40) expression -> ( . expression )
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . NAME = expression
    (15) expression -> . type NAME = expression
    (19) expression -> . NAME ( call_args )
    (23) expression -> . error ; expression
    (24) expression -> . expression ; expression
    (25) expression -> . { expression }
    (26) expression -> . IF expression THEN expression else_expression
    (29) expression -> . WHILE expression DO expression END
    (30) expression -> . expression + expression
    (31) expression -> . expression - expression
    (32) expression -> . expression * expression
    (33) expression -> . expression / expression
    (34) expression -> . expression ^ expression
    (35) expression -> . expression EQ expression
    (36) expression -> . expression > expression
    (37) expression -> . expression < expression
    (38) expression -> . expression NEQ expression
    (39) expression -> . - expression
    (40) expression -> . ( expression )
    (41) expression -> . NUMBER
    (42) expression -> . FLOAT
    (43) expression -> . STRING
    (44) expression -> . TRUE
    (45) expression -> . FALSE
    (46) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    NAME            shift and go to state 4
    error           shift and go to state 11
    {               shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    -               shift and go to state 5
    (               shift and go to state 10
    NUMBER          shift and go to state 15
    FLOAT           shift and go to state 16
    STRING          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    2INT            shift and go to state 20
    2STR            shift and go to state 21
    2FLOAT          shift and go to state 22
    2BOOL           shift and go to state 23
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    expression                     shift and go to state 47
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 11

    (23) expression -> error . ; expression

    ;               shift and go to state 48


state 12

    (25) expression -> { . expression }
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . NAME = expression
    (15) expression -> . type NAME = expression
    (19) expression -> . NAME ( call_args )
    (23) expression -> . error ; expression
    (24) expression -> . expression ; expression
    (25) expression -> . { expression }
    (26) expression -> . IF expression THEN expression else_expression
    (29) expression -> . WHILE expression DO expression END
    (30) expression -> . expression + expression
    (31) expression -> . expression - expression
    (32) expression -> . expression * expression
    (33) expression -> . expression / expression
    (34) expression -> . expression ^ expression
    (35) expression -> . expression EQ expression
    (36) expression -> . expression > expression
    (37) expression -> . expression < expression
    (38) expression -> . expression NEQ expression
    (39) expression -> . - expression
    (40) expression -> . ( expression )
    (41) expression -> . NUMBER
    (42) expression -> . FLOAT
    (43) expression -> . STRING
    (44) expression -> . TRUE
    (45) expression -> . FALSE
    (46) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    NAME            shift and go to state 4
    error           shift and go to state 11
    {               shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    -               shift and go to state 5
    (               shift and go to state 10
    NUMBER          shift and go to state 15
    FLOAT           shift and go to state 16
    STRING          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    2INT            shift and go to state 20
    2STR            shift and go to state 21
    2FLOAT          shift and go to state 22
    2BOOL           shift and go to state 23
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    expression                     shift and go to state 49
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 13

    (26) expression -> IF . expression THEN expression else_expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . NAME = expression
    (15) expression -> . type NAME = expression
    (19) expression -> . NAME ( call_args )
    (23) expression -> . error ; expression
    (24) expression -> . expression ; expression
    (25) expression -> . { expression }
    (26) expression -> . IF expression THEN expression else_expression
    (29) expression -> . WHILE expression DO expression END
    (30) expression -> . expression + expression
    (31) expression -> . expression - expression
    (32) expression -> . expression * expression
    (33) expression -> . expression / expression
    (34) expression -> . expression ^ expression
    (35) expression -> . expression EQ expression
    (36) expression -> . expression > expression
    (37) expression -> . expression < expression
    (38) expression -> . expression NEQ expression
    (39) expression -> . - expression
    (40) expression -> . ( expression )
    (41) expression -> . NUMBER
    (42) expression -> . FLOAT
    (43) expression -> . STRING
    (44) expression -> . TRUE
    (45) expression -> . FALSE
    (46) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    NAME            shift and go to state 4
    error           shift and go to state 11
    {               shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    -               shift and go to state 5
    (               shift and go to state 10
    NUMBER          shift and go to state 15
    FLOAT           shift and go to state 16
    STRING          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    2INT            shift and go to state 20
    2STR            shift and go to state 21
    2FLOAT          shift and go to state 22
    2BOOL           shift and go to state 23
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    expression                     shift and go to state 50
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 14

    (29) expression -> WHILE . expression DO expression END
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . NAME = expression
    (15) expression -> . type NAME = expression
    (19) expression -> . NAME ( call_args )
    (23) expression -> . error ; expression
    (24) expression -> . expression ; expression
    (25) expression -> . { expression }
    (26) expression -> . IF expression THEN expression else_expression
    (29) expression -> . WHILE expression DO expression END
    (30) expression -> . expression + expression
    (31) expression -> . expression - expression
    (32) expression -> . expression * expression
    (33) expression -> . expression / expression
    (34) expression -> . expression ^ expression
    (35) expression -> . expression EQ expression
    (36) expression -> . expression > expression
    (37) expression -> . expression < expression
    (38) expression -> . expression NEQ expression
    (39) expression -> . - expression
    (40) expression -> . ( expression )
    (41) expression -> . NUMBER
    (42) expression -> . FLOAT
    (43) expression -> . STRING
    (44) expression -> . TRUE
    (45) expression -> . FALSE
    (46) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    NAME            shift and go to state 4
    error           shift and go to state 11
    {               shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    -               shift and go to state 5
    (               shift and go to state 10
    NUMBER          shift and go to state 15
    FLOAT           shift and go to state 16
    STRING          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    2INT            shift and go to state 20
    2STR            shift and go to state 21
    2FLOAT          shift and go to state 22
    2BOOL           shift and go to state 23
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    expression                     shift and go to state 51
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 15

    (41) expression -> NUMBER .

    ;               reduce using rule 41 (expression -> NUMBER .)
    +               reduce using rule 41 (expression -> NUMBER .)
    -               reduce using rule 41 (expression -> NUMBER .)
    *               reduce using rule 41 (expression -> NUMBER .)
    /               reduce using rule 41 (expression -> NUMBER .)
    ^               reduce using rule 41 (expression -> NUMBER .)
    EQ              reduce using rule 41 (expression -> NUMBER .)
    >               reduce using rule 41 (expression -> NUMBER .)
    <               reduce using rule 41 (expression -> NUMBER .)
    NEQ             reduce using rule 41 (expression -> NUMBER .)
    $end            reduce using rule 41 (expression -> NUMBER .)
    )               reduce using rule 41 (expression -> NUMBER .)
    }               reduce using rule 41 (expression -> NUMBER .)
    THEN            reduce using rule 41 (expression -> NUMBER .)
    DO              reduce using rule 41 (expression -> NUMBER .)
    ,               reduce using rule 41 (expression -> NUMBER .)
    ELSE            reduce using rule 41 (expression -> NUMBER .)
    END             reduce using rule 41 (expression -> NUMBER .)


state 16

    (42) expression -> FLOAT .

    ;               reduce using rule 42 (expression -> FLOAT .)
    +               reduce using rule 42 (expression -> FLOAT .)
    -               reduce using rule 42 (expression -> FLOAT .)
    *               reduce using rule 42 (expression -> FLOAT .)
    /               reduce using rule 42 (expression -> FLOAT .)
    ^               reduce using rule 42 (expression -> FLOAT .)
    EQ              reduce using rule 42 (expression -> FLOAT .)
    >               reduce using rule 42 (expression -> FLOAT .)
    <               reduce using rule 42 (expression -> FLOAT .)
    NEQ             reduce using rule 42 (expression -> FLOAT .)
    $end            reduce using rule 42 (expression -> FLOAT .)
    )               reduce using rule 42 (expression -> FLOAT .)
    }               reduce using rule 42 (expression -> FLOAT .)
    THEN            reduce using rule 42 (expression -> FLOAT .)
    DO              reduce using rule 42 (expression -> FLOAT .)
    ,               reduce using rule 42 (expression -> FLOAT .)
    ELSE            reduce using rule 42 (expression -> FLOAT .)
    END             reduce using rule 42 (expression -> FLOAT .)


state 17

    (43) expression -> STRING .

    ;               reduce using rule 43 (expression -> STRING .)
    +               reduce using rule 43 (expression -> STRING .)
    -               reduce using rule 43 (expression -> STRING .)
    *               reduce using rule 43 (expression -> STRING .)
    /               reduce using rule 43 (expression -> STRING .)
    ^               reduce using rule 43 (expression -> STRING .)
    EQ              reduce using rule 43 (expression -> STRING .)
    >               reduce using rule 43 (expression -> STRING .)
    <               reduce using rule 43 (expression -> STRING .)
    NEQ             reduce using rule 43 (expression -> STRING .)
    $end            reduce using rule 43 (expression -> STRING .)
    )               reduce using rule 43 (expression -> STRING .)
    }               reduce using rule 43 (expression -> STRING .)
    THEN            reduce using rule 43 (expression -> STRING .)
    DO              reduce using rule 43 (expression -> STRING .)
    ,               reduce using rule 43 (expression -> STRING .)
    ELSE            reduce using rule 43 (expression -> STRING .)
    END             reduce using rule 43 (expression -> STRING .)


state 18

    (44) expression -> TRUE .

    ;               reduce using rule 44 (expression -> TRUE .)
    +               reduce using rule 44 (expression -> TRUE .)
    -               reduce using rule 44 (expression -> TRUE .)
    *               reduce using rule 44 (expression -> TRUE .)
    /               reduce using rule 44 (expression -> TRUE .)
    ^               reduce using rule 44 (expression -> TRUE .)
    EQ              reduce using rule 44 (expression -> TRUE .)
    >               reduce using rule 44 (expression -> TRUE .)
    <               reduce using rule 44 (expression -> TRUE .)
    NEQ             reduce using rule 44 (expression -> TRUE .)
    $end            reduce using rule 44 (expression -> TRUE .)
    )               reduce using rule 44 (expression -> TRUE .)
    }               reduce using rule 44 (expression -> TRUE .)
    THEN            reduce using rule 44 (expression -> TRUE .)
    DO              reduce using rule 44 (expression -> TRUE .)
    ,               reduce using rule 44 (expression -> TRUE .)
    ELSE            reduce using rule 44 (expression -> TRUE .)
    END             reduce using rule 44 (expression -> TRUE .)


state 19

    (45) expression -> FALSE .

    ;               reduce using rule 45 (expression -> FALSE .)
    +               reduce using rule 45 (expression -> FALSE .)
    -               reduce using rule 45 (expression -> FALSE .)
    *               reduce using rule 45 (expression -> FALSE .)
    /               reduce using rule 45 (expression -> FALSE .)
    ^               reduce using rule 45 (expression -> FALSE .)
    EQ              reduce using rule 45 (expression -> FALSE .)
    >               reduce using rule 45 (expression -> FALSE .)
    <               reduce using rule 45 (expression -> FALSE .)
    NEQ             reduce using rule 45 (expression -> FALSE .)
    $end            reduce using rule 45 (expression -> FALSE .)
    )               reduce using rule 45 (expression -> FALSE .)
    }               reduce using rule 45 (expression -> FALSE .)
    THEN            reduce using rule 45 (expression -> FALSE .)
    DO              reduce using rule 45 (expression -> FALSE .)
    ,               reduce using rule 45 (expression -> FALSE .)
    ELSE            reduce using rule 45 (expression -> FALSE .)
    END             reduce using rule 45 (expression -> FALSE .)


state 20

    (3) convert -> 2INT .

    NOT             reduce using rule 3 (convert -> 2INT .)
    PRINT           reduce using rule 3 (convert -> 2INT .)
    NAME            reduce using rule 3 (convert -> 2INT .)
    error           reduce using rule 3 (convert -> 2INT .)
    {               reduce using rule 3 (convert -> 2INT .)
    IF              reduce using rule 3 (convert -> 2INT .)
    WHILE           reduce using rule 3 (convert -> 2INT .)
    -               reduce using rule 3 (convert -> 2INT .)
    (               reduce using rule 3 (convert -> 2INT .)
    NUMBER          reduce using rule 3 (convert -> 2INT .)
    FLOAT           reduce using rule 3 (convert -> 2INT .)
    STRING          reduce using rule 3 (convert -> 2INT .)
    TRUE            reduce using rule 3 (convert -> 2INT .)
    FALSE           reduce using rule 3 (convert -> 2INT .)
    2INT            reduce using rule 3 (convert -> 2INT .)
    2STR            reduce using rule 3 (convert -> 2INT .)
    2FLOAT          reduce using rule 3 (convert -> 2INT .)
    2BOOL           reduce using rule 3 (convert -> 2INT .)
    STRING_TYPE     reduce using rule 3 (convert -> 2INT .)
    INT_TYPE        reduce using rule 3 (convert -> 2INT .)
    FLOAT_TYPE      reduce using rule 3 (convert -> 2INT .)
    BOOL_TYPE       reduce using rule 3 (convert -> 2INT .)


state 21

    (4) convert -> 2STR .

    NOT             reduce using rule 4 (convert -> 2STR .)
    PRINT           reduce using rule 4 (convert -> 2STR .)
    NAME            reduce using rule 4 (convert -> 2STR .)
    error           reduce using rule 4 (convert -> 2STR .)
    {               reduce using rule 4 (convert -> 2STR .)
    IF              reduce using rule 4 (convert -> 2STR .)
    WHILE           reduce using rule 4 (convert -> 2STR .)
    -               reduce using rule 4 (convert -> 2STR .)
    (               reduce using rule 4 (convert -> 2STR .)
    NUMBER          reduce using rule 4 (convert -> 2STR .)
    FLOAT           reduce using rule 4 (convert -> 2STR .)
    STRING          reduce using rule 4 (convert -> 2STR .)
    TRUE            reduce using rule 4 (convert -> 2STR .)
    FALSE           reduce using rule 4 (convert -> 2STR .)
    2INT            reduce using rule 4 (convert -> 2STR .)
    2STR            reduce using rule 4 (convert -> 2STR .)
    2FLOAT          reduce using rule 4 (convert -> 2STR .)
    2BOOL           reduce using rule 4 (convert -> 2STR .)
    STRING_TYPE     reduce using rule 4 (convert -> 2STR .)
    INT_TYPE        reduce using rule 4 (convert -> 2STR .)
    FLOAT_TYPE      reduce using rule 4 (convert -> 2STR .)
    BOOL_TYPE       reduce using rule 4 (convert -> 2STR .)


state 22

    (5) convert -> 2FLOAT .

    NOT             reduce using rule 5 (convert -> 2FLOAT .)
    PRINT           reduce using rule 5 (convert -> 2FLOAT .)
    NAME            reduce using rule 5 (convert -> 2FLOAT .)
    error           reduce using rule 5 (convert -> 2FLOAT .)
    {               reduce using rule 5 (convert -> 2FLOAT .)
    IF              reduce using rule 5 (convert -> 2FLOAT .)
    WHILE           reduce using rule 5 (convert -> 2FLOAT .)
    -               reduce using rule 5 (convert -> 2FLOAT .)
    (               reduce using rule 5 (convert -> 2FLOAT .)
    NUMBER          reduce using rule 5 (convert -> 2FLOAT .)
    FLOAT           reduce using rule 5 (convert -> 2FLOAT .)
    STRING          reduce using rule 5 (convert -> 2FLOAT .)
    TRUE            reduce using rule 5 (convert -> 2FLOAT .)
    FALSE           reduce using rule 5 (convert -> 2FLOAT .)
    2INT            reduce using rule 5 (convert -> 2FLOAT .)
    2STR            reduce using rule 5 (convert -> 2FLOAT .)
    2FLOAT          reduce using rule 5 (convert -> 2FLOAT .)
    2BOOL           reduce using rule 5 (convert -> 2FLOAT .)
    STRING_TYPE     reduce using rule 5 (convert -> 2FLOAT .)
    INT_TYPE        reduce using rule 5 (convert -> 2FLOAT .)
    FLOAT_TYPE      reduce using rule 5 (convert -> 2FLOAT .)
    BOOL_TYPE       reduce using rule 5 (convert -> 2FLOAT .)


state 23

    (6) convert -> 2BOOL .

    NOT             reduce using rule 6 (convert -> 2BOOL .)
    PRINT           reduce using rule 6 (convert -> 2BOOL .)
    NAME            reduce using rule 6 (convert -> 2BOOL .)
    error           reduce using rule 6 (convert -> 2BOOL .)
    {               reduce using rule 6 (convert -> 2BOOL .)
    IF              reduce using rule 6 (convert -> 2BOOL .)
    WHILE           reduce using rule 6 (convert -> 2BOOL .)
    -               reduce using rule 6 (convert -> 2BOOL .)
    (               reduce using rule 6 (convert -> 2BOOL .)
    NUMBER          reduce using rule 6 (convert -> 2BOOL .)
    FLOAT           reduce using rule 6 (convert -> 2BOOL .)
    STRING          reduce using rule 6 (convert -> 2BOOL .)
    TRUE            reduce using rule 6 (convert -> 2BOOL .)
    FALSE           reduce using rule 6 (convert -> 2BOOL .)
    2INT            reduce using rule 6 (convert -> 2BOOL .)
    2STR            reduce using rule 6 (convert -> 2BOOL .)
    2FLOAT          reduce using rule 6 (convert -> 2BOOL .)
    2BOOL           reduce using rule 6 (convert -> 2BOOL .)
    STRING_TYPE     reduce using rule 6 (convert -> 2BOOL .)
    INT_TYPE        reduce using rule 6 (convert -> 2BOOL .)
    FLOAT_TYPE      reduce using rule 6 (convert -> 2BOOL .)
    BOOL_TYPE       reduce using rule 6 (convert -> 2BOOL .)


state 24

    (11) type -> STRING_TYPE .

    NAME            reduce using rule 11 (type -> STRING_TYPE .)
    =               reduce using rule 11 (type -> STRING_TYPE .)


state 25

    (12) type -> INT_TYPE .

    NAME            reduce using rule 12 (type -> INT_TYPE .)
    =               reduce using rule 12 (type -> INT_TYPE .)


state 26

    (13) type -> FLOAT_TYPE .

    NAME            reduce using rule 13 (type -> FLOAT_TYPE .)
    =               reduce using rule 13 (type -> FLOAT_TYPE .)


state 27

    (14) type -> BOOL_TYPE .

    NAME            reduce using rule 14 (type -> BOOL_TYPE .)
    =               reduce using rule 14 (type -> BOOL_TYPE .)


state 28

    (2) statement -> statement ; . statement
    (1) statement -> . expression
    (2) statement -> . statement ; statement
    (16) statement -> . DEF NAME args - > type = expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . NAME = expression
    (15) expression -> . type NAME = expression
    (19) expression -> . NAME ( call_args )
    (23) expression -> . error ; expression
    (24) expression -> . expression ; expression
    (25) expression -> . { expression }
    (26) expression -> . IF expression THEN expression else_expression
    (29) expression -> . WHILE expression DO expression END
    (30) expression -> . expression + expression
    (31) expression -> . expression - expression
    (32) expression -> . expression * expression
    (33) expression -> . expression / expression
    (34) expression -> . expression ^ expression
    (35) expression -> . expression EQ expression
    (36) expression -> . expression > expression
    (37) expression -> . expression < expression
    (38) expression -> . expression NEQ expression
    (39) expression -> . - expression
    (40) expression -> . ( expression )
    (41) expression -> . NUMBER
    (42) expression -> . FLOAT
    (43) expression -> . STRING
    (44) expression -> . TRUE
    (45) expression -> . FALSE
    (46) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    DEF             shift and go to state 3
    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    NAME            shift and go to state 4
    error           shift and go to state 11
    {               shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    -               shift and go to state 5
    (               shift and go to state 10
    NUMBER          shift and go to state 15
    FLOAT           shift and go to state 16
    STRING          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    2INT            shift and go to state 20
    2STR            shift and go to state 21
    2FLOAT          shift and go to state 22
    2BOOL           shift and go to state 23
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    statement                      shift and go to state 52
    expression                     shift and go to state 2
    type                           shift and go to state 6
    convert                        shift and go to state 7

state 29

    (24) expression -> expression ; . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . NAME = expression
    (15) expression -> . type NAME = expression
    (19) expression -> . NAME ( call_args )
    (23) expression -> . error ; expression
    (24) expression -> . expression ; expression
    (25) expression -> . { expression }
    (26) expression -> . IF expression THEN expression else_expression
    (29) expression -> . WHILE expression DO expression END
    (30) expression -> . expression + expression
    (31) expression -> . expression - expression
    (32) expression -> . expression * expression
    (33) expression -> . expression / expression
    (34) expression -> . expression ^ expression
    (35) expression -> . expression EQ expression
    (36) expression -> . expression > expression
    (37) expression -> . expression < expression
    (38) expression -> . expression NEQ expression
    (39) expression -> . - expression
    (40) expression -> . ( expression )
    (41) expression -> . NUMBER
    (42) expression -> . FLOAT
    (43) expression -> . STRING
    (44) expression -> . TRUE
    (45) expression -> . FALSE
    (46) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    NAME            shift and go to state 4
    error           shift and go to state 11
    {               shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    -               shift and go to state 5
    (               shift and go to state 10
    NUMBER          shift and go to state 15
    FLOAT           shift and go to state 16
    STRING          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    2INT            shift and go to state 20
    2STR            shift and go to state 21
    2FLOAT          shift and go to state 22
    2BOOL           shift and go to state 23
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    expression                     shift and go to state 53
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 30

    (30) expression -> expression + . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . NAME = expression
    (15) expression -> . type NAME = expression
    (19) expression -> . NAME ( call_args )
    (23) expression -> . error ; expression
    (24) expression -> . expression ; expression
    (25) expression -> . { expression }
    (26) expression -> . IF expression THEN expression else_expression
    (29) expression -> . WHILE expression DO expression END
    (30) expression -> . expression + expression
    (31) expression -> . expression - expression
    (32) expression -> . expression * expression
    (33) expression -> . expression / expression
    (34) expression -> . expression ^ expression
    (35) expression -> . expression EQ expression
    (36) expression -> . expression > expression
    (37) expression -> . expression < expression
    (38) expression -> . expression NEQ expression
    (39) expression -> . - expression
    (40) expression -> . ( expression )
    (41) expression -> . NUMBER
    (42) expression -> . FLOAT
    (43) expression -> . STRING
    (44) expression -> . TRUE
    (45) expression -> . FALSE
    (46) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    NAME            shift and go to state 4
    error           shift and go to state 11
    {               shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    -               shift and go to state 5
    (               shift and go to state 10
    NUMBER          shift and go to state 15
    FLOAT           shift and go to state 16
    STRING          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    2INT            shift and go to state 20
    2STR            shift and go to state 21
    2FLOAT          shift and go to state 22
    2BOOL           shift and go to state 23
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    expression                     shift and go to state 54
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 31

    (31) expression -> expression - . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . NAME = expression
    (15) expression -> . type NAME = expression
    (19) expression -> . NAME ( call_args )
    (23) expression -> . error ; expression
    (24) expression -> . expression ; expression
    (25) expression -> . { expression }
    (26) expression -> . IF expression THEN expression else_expression
    (29) expression -> . WHILE expression DO expression END
    (30) expression -> . expression + expression
    (31) expression -> . expression - expression
    (32) expression -> . expression * expression
    (33) expression -> . expression / expression
    (34) expression -> . expression ^ expression
    (35) expression -> . expression EQ expression
    (36) expression -> . expression > expression
    (37) expression -> . expression < expression
    (38) expression -> . expression NEQ expression
    (39) expression -> . - expression
    (40) expression -> . ( expression )
    (41) expression -> . NUMBER
    (42) expression -> . FLOAT
    (43) expression -> . STRING
    (44) expression -> . TRUE
    (45) expression -> . FALSE
    (46) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    NAME            shift and go to state 4
    error           shift and go to state 11
    {               shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    -               shift and go to state 5
    (               shift and go to state 10
    NUMBER          shift and go to state 15
    FLOAT           shift and go to state 16
    STRING          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    2INT            shift and go to state 20
    2STR            shift and go to state 21
    2FLOAT          shift and go to state 22
    2BOOL           shift and go to state 23
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    expression                     shift and go to state 55
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 32

    (32) expression -> expression * . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . NAME = expression
    (15) expression -> . type NAME = expression
    (19) expression -> . NAME ( call_args )
    (23) expression -> . error ; expression
    (24) expression -> . expression ; expression
    (25) expression -> . { expression }
    (26) expression -> . IF expression THEN expression else_expression
    (29) expression -> . WHILE expression DO expression END
    (30) expression -> . expression + expression
    (31) expression -> . expression - expression
    (32) expression -> . expression * expression
    (33) expression -> . expression / expression
    (34) expression -> . expression ^ expression
    (35) expression -> . expression EQ expression
    (36) expression -> . expression > expression
    (37) expression -> . expression < expression
    (38) expression -> . expression NEQ expression
    (39) expression -> . - expression
    (40) expression -> . ( expression )
    (41) expression -> . NUMBER
    (42) expression -> . FLOAT
    (43) expression -> . STRING
    (44) expression -> . TRUE
    (45) expression -> . FALSE
    (46) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    NAME            shift and go to state 4
    error           shift and go to state 11
    {               shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    -               shift and go to state 5
    (               shift and go to state 10
    NUMBER          shift and go to state 15
    FLOAT           shift and go to state 16
    STRING          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    2INT            shift and go to state 20
    2STR            shift and go to state 21
    2FLOAT          shift and go to state 22
    2BOOL           shift and go to state 23
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    expression                     shift and go to state 56
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 33

    (33) expression -> expression / . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . NAME = expression
    (15) expression -> . type NAME = expression
    (19) expression -> . NAME ( call_args )
    (23) expression -> . error ; expression
    (24) expression -> . expression ; expression
    (25) expression -> . { expression }
    (26) expression -> . IF expression THEN expression else_expression
    (29) expression -> . WHILE expression DO expression END
    (30) expression -> . expression + expression
    (31) expression -> . expression - expression
    (32) expression -> . expression * expression
    (33) expression -> . expression / expression
    (34) expression -> . expression ^ expression
    (35) expression -> . expression EQ expression
    (36) expression -> . expression > expression
    (37) expression -> . expression < expression
    (38) expression -> . expression NEQ expression
    (39) expression -> . - expression
    (40) expression -> . ( expression )
    (41) expression -> . NUMBER
    (42) expression -> . FLOAT
    (43) expression -> . STRING
    (44) expression -> . TRUE
    (45) expression -> . FALSE
    (46) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    NAME            shift and go to state 4
    error           shift and go to state 11
    {               shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    -               shift and go to state 5
    (               shift and go to state 10
    NUMBER          shift and go to state 15
    FLOAT           shift and go to state 16
    STRING          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    2INT            shift and go to state 20
    2STR            shift and go to state 21
    2FLOAT          shift and go to state 22
    2BOOL           shift and go to state 23
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    expression                     shift and go to state 57
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 34

    (34) expression -> expression ^ . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . NAME = expression
    (15) expression -> . type NAME = expression
    (19) expression -> . NAME ( call_args )
    (23) expression -> . error ; expression
    (24) expression -> . expression ; expression
    (25) expression -> . { expression }
    (26) expression -> . IF expression THEN expression else_expression
    (29) expression -> . WHILE expression DO expression END
    (30) expression -> . expression + expression
    (31) expression -> . expression - expression
    (32) expression -> . expression * expression
    (33) expression -> . expression / expression
    (34) expression -> . expression ^ expression
    (35) expression -> . expression EQ expression
    (36) expression -> . expression > expression
    (37) expression -> . expression < expression
    (38) expression -> . expression NEQ expression
    (39) expression -> . - expression
    (40) expression -> . ( expression )
    (41) expression -> . NUMBER
    (42) expression -> . FLOAT
    (43) expression -> . STRING
    (44) expression -> . TRUE
    (45) expression -> . FALSE
    (46) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    NAME            shift and go to state 4
    error           shift and go to state 11
    {               shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    -               shift and go to state 5
    (               shift and go to state 10
    NUMBER          shift and go to state 15
    FLOAT           shift and go to state 16
    STRING          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    2INT            shift and go to state 20
    2STR            shift and go to state 21
    2FLOAT          shift and go to state 22
    2BOOL           shift and go to state 23
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    expression                     shift and go to state 58
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 35

    (35) expression -> expression EQ . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . NAME = expression
    (15) expression -> . type NAME = expression
    (19) expression -> . NAME ( call_args )
    (23) expression -> . error ; expression
    (24) expression -> . expression ; expression
    (25) expression -> . { expression }
    (26) expression -> . IF expression THEN expression else_expression
    (29) expression -> . WHILE expression DO expression END
    (30) expression -> . expression + expression
    (31) expression -> . expression - expression
    (32) expression -> . expression * expression
    (33) expression -> . expression / expression
    (34) expression -> . expression ^ expression
    (35) expression -> . expression EQ expression
    (36) expression -> . expression > expression
    (37) expression -> . expression < expression
    (38) expression -> . expression NEQ expression
    (39) expression -> . - expression
    (40) expression -> . ( expression )
    (41) expression -> . NUMBER
    (42) expression -> . FLOAT
    (43) expression -> . STRING
    (44) expression -> . TRUE
    (45) expression -> . FALSE
    (46) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    NAME            shift and go to state 4
    error           shift and go to state 11
    {               shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    -               shift and go to state 5
    (               shift and go to state 10
    NUMBER          shift and go to state 15
    FLOAT           shift and go to state 16
    STRING          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    2INT            shift and go to state 20
    2STR            shift and go to state 21
    2FLOAT          shift and go to state 22
    2BOOL           shift and go to state 23
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    expression                     shift and go to state 59
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 36

    (36) expression -> expression > . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . NAME = expression
    (15) expression -> . type NAME = expression
    (19) expression -> . NAME ( call_args )
    (23) expression -> . error ; expression
    (24) expression -> . expression ; expression
    (25) expression -> . { expression }
    (26) expression -> . IF expression THEN expression else_expression
    (29) expression -> . WHILE expression DO expression END
    (30) expression -> . expression + expression
    (31) expression -> . expression - expression
    (32) expression -> . expression * expression
    (33) expression -> . expression / expression
    (34) expression -> . expression ^ expression
    (35) expression -> . expression EQ expression
    (36) expression -> . expression > expression
    (37) expression -> . expression < expression
    (38) expression -> . expression NEQ expression
    (39) expression -> . - expression
    (40) expression -> . ( expression )
    (41) expression -> . NUMBER
    (42) expression -> . FLOAT
    (43) expression -> . STRING
    (44) expression -> . TRUE
    (45) expression -> . FALSE
    (46) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    NAME            shift and go to state 4
    error           shift and go to state 11
    {               shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    -               shift and go to state 5
    (               shift and go to state 10
    NUMBER          shift and go to state 15
    FLOAT           shift and go to state 16
    STRING          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    2INT            shift and go to state 20
    2STR            shift and go to state 21
    2FLOAT          shift and go to state 22
    2BOOL           shift and go to state 23
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    expression                     shift and go to state 60
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 37

    (37) expression -> expression < . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . NAME = expression
    (15) expression -> . type NAME = expression
    (19) expression -> . NAME ( call_args )
    (23) expression -> . error ; expression
    (24) expression -> . expression ; expression
    (25) expression -> . { expression }
    (26) expression -> . IF expression THEN expression else_expression
    (29) expression -> . WHILE expression DO expression END
    (30) expression -> . expression + expression
    (31) expression -> . expression - expression
    (32) expression -> . expression * expression
    (33) expression -> . expression / expression
    (34) expression -> . expression ^ expression
    (35) expression -> . expression EQ expression
    (36) expression -> . expression > expression
    (37) expression -> . expression < expression
    (38) expression -> . expression NEQ expression
    (39) expression -> . - expression
    (40) expression -> . ( expression )
    (41) expression -> . NUMBER
    (42) expression -> . FLOAT
    (43) expression -> . STRING
    (44) expression -> . TRUE
    (45) expression -> . FALSE
    (46) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    NAME            shift and go to state 4
    error           shift and go to state 11
    {               shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    -               shift and go to state 5
    (               shift and go to state 10
    NUMBER          shift and go to state 15
    FLOAT           shift and go to state 16
    STRING          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    2INT            shift and go to state 20
    2STR            shift and go to state 21
    2FLOAT          shift and go to state 22
    2BOOL           shift and go to state 23
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    expression                     shift and go to state 61
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 38

    (38) expression -> expression NEQ . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . NAME = expression
    (15) expression -> . type NAME = expression
    (19) expression -> . NAME ( call_args )
    (23) expression -> . error ; expression
    (24) expression -> . expression ; expression
    (25) expression -> . { expression }
    (26) expression -> . IF expression THEN expression else_expression
    (29) expression -> . WHILE expression DO expression END
    (30) expression -> . expression + expression
    (31) expression -> . expression - expression
    (32) expression -> . expression * expression
    (33) expression -> . expression / expression
    (34) expression -> . expression ^ expression
    (35) expression -> . expression EQ expression
    (36) expression -> . expression > expression
    (37) expression -> . expression < expression
    (38) expression -> . expression NEQ expression
    (39) expression -> . - expression
    (40) expression -> . ( expression )
    (41) expression -> . NUMBER
    (42) expression -> . FLOAT
    (43) expression -> . STRING
    (44) expression -> . TRUE
    (45) expression -> . FALSE
    (46) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    NAME            shift and go to state 4
    error           shift and go to state 11
    {               shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    -               shift and go to state 5
    (               shift and go to state 10
    NUMBER          shift and go to state 15
    FLOAT           shift and go to state 16
    STRING          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    2INT            shift and go to state 20
    2STR            shift and go to state 21
    2FLOAT          shift and go to state 22
    2BOOL           shift and go to state 23
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    expression                     shift and go to state 62
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 39

    (16) statement -> DEF NAME . args - > type = expression
    (17) args -> . empty
    (18) args -> . type NAME args
    (47) empty -> .
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    -               reduce using rule 47 (empty -> .)
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    args                           shift and go to state 63
    type                           shift and go to state 64
    empty                          shift and go to state 65

state 40

    (10) expression -> NAME = . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . NAME = expression
    (15) expression -> . type NAME = expression
    (19) expression -> . NAME ( call_args )
    (23) expression -> . error ; expression
    (24) expression -> . expression ; expression
    (25) expression -> . { expression }
    (26) expression -> . IF expression THEN expression else_expression
    (29) expression -> . WHILE expression DO expression END
    (30) expression -> . expression + expression
    (31) expression -> . expression - expression
    (32) expression -> . expression * expression
    (33) expression -> . expression / expression
    (34) expression -> . expression ^ expression
    (35) expression -> . expression EQ expression
    (36) expression -> . expression > expression
    (37) expression -> . expression < expression
    (38) expression -> . expression NEQ expression
    (39) expression -> . - expression
    (40) expression -> . ( expression )
    (41) expression -> . NUMBER
    (42) expression -> . FLOAT
    (43) expression -> . STRING
    (44) expression -> . TRUE
    (45) expression -> . FALSE
    (46) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    NAME            shift and go to state 4
    error           shift and go to state 11
    {               shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    -               shift and go to state 5
    (               shift and go to state 10
    NUMBER          shift and go to state 15
    FLOAT           shift and go to state 16
    STRING          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    2INT            shift and go to state 20
    2STR            shift and go to state 21
    2FLOAT          shift and go to state 22
    2BOOL           shift and go to state 23
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    expression                     shift and go to state 66
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 41

    (19) expression -> NAME ( . call_args )
    (20) call_args -> . empty
    (21) call_args -> . expression
    (22) call_args -> . expression , call_args
    (47) empty -> .
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . NAME = expression
    (15) expression -> . type NAME = expression
    (19) expression -> . NAME ( call_args )
    (23) expression -> . error ; expression
    (24) expression -> . expression ; expression
    (25) expression -> . { expression }
    (26) expression -> . IF expression THEN expression else_expression
    (29) expression -> . WHILE expression DO expression END
    (30) expression -> . expression + expression
    (31) expression -> . expression - expression
    (32) expression -> . expression * expression
    (33) expression -> . expression / expression
    (34) expression -> . expression ^ expression
    (35) expression -> . expression EQ expression
    (36) expression -> . expression > expression
    (37) expression -> . expression < expression
    (38) expression -> . expression NEQ expression
    (39) expression -> . - expression
    (40) expression -> . ( expression )
    (41) expression -> . NUMBER
    (42) expression -> . FLOAT
    (43) expression -> . STRING
    (44) expression -> . TRUE
    (45) expression -> . FALSE
    (46) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    )               reduce using rule 47 (empty -> .)
    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    NAME            shift and go to state 4
    error           shift and go to state 11
    {               shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    -               shift and go to state 5
    (               shift and go to state 10
    NUMBER          shift and go to state 15
    FLOAT           shift and go to state 16
    STRING          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    2INT            shift and go to state 20
    2STR            shift and go to state 21
    2FLOAT          shift and go to state 22
    2BOOL           shift and go to state 23
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    call_args                      shift and go to state 67
    empty                          shift and go to state 68
    expression                     shift and go to state 69
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 42

    (39) expression -> - expression .
    (24) expression -> expression . ; expression
    (30) expression -> expression . + expression
    (31) expression -> expression . - expression
    (32) expression -> expression . * expression
    (33) expression -> expression . / expression
    (34) expression -> expression . ^ expression
    (35) expression -> expression . EQ expression
    (36) expression -> expression . > expression
    (37) expression -> expression . < expression
    (38) expression -> expression . NEQ expression

    ;               reduce using rule 39 (expression -> - expression .)
    +               reduce using rule 39 (expression -> - expression .)
    -               reduce using rule 39 (expression -> - expression .)
    *               reduce using rule 39 (expression -> - expression .)
    /               reduce using rule 39 (expression -> - expression .)
    ^               reduce using rule 39 (expression -> - expression .)
    EQ              reduce using rule 39 (expression -> - expression .)
    >               reduce using rule 39 (expression -> - expression .)
    <               reduce using rule 39 (expression -> - expression .)
    NEQ             reduce using rule 39 (expression -> - expression .)
    $end            reduce using rule 39 (expression -> - expression .)
    )               reduce using rule 39 (expression -> - expression .)
    }               reduce using rule 39 (expression -> - expression .)
    THEN            reduce using rule 39 (expression -> - expression .)
    DO              reduce using rule 39 (expression -> - expression .)
    ,               reduce using rule 39 (expression -> - expression .)
    ELSE            reduce using rule 39 (expression -> - expression .)
    END             reduce using rule 39 (expression -> - expression .)

  ! ;               [ shift and go to state 29 ]
  ! +               [ shift and go to state 30 ]
  ! -               [ shift and go to state 31 ]
  ! *               [ shift and go to state 32 ]
  ! /               [ shift and go to state 33 ]
  ! ^               [ shift and go to state 34 ]
  ! EQ              [ shift and go to state 35 ]
  ! >               [ shift and go to state 36 ]
  ! <               [ shift and go to state 37 ]
  ! NEQ             [ shift and go to state 38 ]


state 43

    (15) expression -> type NAME . = expression

    =               shift and go to state 70


state 44

    (7) expression -> convert expression .
    (24) expression -> expression . ; expression
    (30) expression -> expression . + expression
    (31) expression -> expression . - expression
    (32) expression -> expression . * expression
    (33) expression -> expression . / expression
    (34) expression -> expression . ^ expression
    (35) expression -> expression . EQ expression
    (36) expression -> expression . > expression
    (37) expression -> expression . < expression
    (38) expression -> expression . NEQ expression

  ! shift/reduce conflict for ; resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
    $end            reduce using rule 7 (expression -> convert expression .)
    )               reduce using rule 7 (expression -> convert expression .)
    }               reduce using rule 7 (expression -> convert expression .)
    THEN            reduce using rule 7 (expression -> convert expression .)
    DO              reduce using rule 7 (expression -> convert expression .)
    ,               reduce using rule 7 (expression -> convert expression .)
    ELSE            reduce using rule 7 (expression -> convert expression .)
    END             reduce using rule 7 (expression -> convert expression .)
    ;               shift and go to state 29
    +               shift and go to state 30
    -               shift and go to state 31
    *               shift and go to state 32
    /               shift and go to state 33
    ^               shift and go to state 34
    EQ              shift and go to state 35
    >               shift and go to state 36
    <               shift and go to state 37
    NEQ             shift and go to state 38

  ! ;               [ reduce using rule 7 (expression -> convert expression .) ]
  ! +               [ reduce using rule 7 (expression -> convert expression .) ]
  ! -               [ reduce using rule 7 (expression -> convert expression .) ]
  ! *               [ reduce using rule 7 (expression -> convert expression .) ]
  ! /               [ reduce using rule 7 (expression -> convert expression .) ]
  ! ^               [ reduce using rule 7 (expression -> convert expression .) ]
  ! EQ              [ reduce using rule 7 (expression -> convert expression .) ]
  ! >               [ reduce using rule 7 (expression -> convert expression .) ]
  ! <               [ reduce using rule 7 (expression -> convert expression .) ]
  ! NEQ             [ reduce using rule 7 (expression -> convert expression .) ]


state 45

    (8) expression -> NOT expression .
    (24) expression -> expression . ; expression
    (30) expression -> expression . + expression
    (31) expression -> expression . - expression
    (32) expression -> expression . * expression
    (33) expression -> expression . / expression
    (34) expression -> expression . ^ expression
    (35) expression -> expression . EQ expression
    (36) expression -> expression . > expression
    (37) expression -> expression . < expression
    (38) expression -> expression . NEQ expression

    ;               reduce using rule 8 (expression -> NOT expression .)
    EQ              reduce using rule 8 (expression -> NOT expression .)
    >               reduce using rule 8 (expression -> NOT expression .)
    <               reduce using rule 8 (expression -> NOT expression .)
    NEQ             reduce using rule 8 (expression -> NOT expression .)
    $end            reduce using rule 8 (expression -> NOT expression .)
    )               reduce using rule 8 (expression -> NOT expression .)
    }               reduce using rule 8 (expression -> NOT expression .)
    THEN            reduce using rule 8 (expression -> NOT expression .)
    DO              reduce using rule 8 (expression -> NOT expression .)
    ,               reduce using rule 8 (expression -> NOT expression .)
    ELSE            reduce using rule 8 (expression -> NOT expression .)
    END             reduce using rule 8 (expression -> NOT expression .)
    +               shift and go to state 30
    -               shift and go to state 31
    *               shift and go to state 32
    /               shift and go to state 33
    ^               shift and go to state 34

  ! +               [ reduce using rule 8 (expression -> NOT expression .) ]
  ! -               [ reduce using rule 8 (expression -> NOT expression .) ]
  ! *               [ reduce using rule 8 (expression -> NOT expression .) ]
  ! /               [ reduce using rule 8 (expression -> NOT expression .) ]
  ! ^               [ reduce using rule 8 (expression -> NOT expression .) ]
  ! ;               [ shift and go to state 29 ]
  ! EQ              [ shift and go to state 35 ]
  ! >               [ shift and go to state 36 ]
  ! <               [ shift and go to state 37 ]
  ! NEQ             [ shift and go to state 38 ]


state 46

    (9) expression -> PRINT expression .
    (24) expression -> expression . ; expression
    (30) expression -> expression . + expression
    (31) expression -> expression . - expression
    (32) expression -> expression . * expression
    (33) expression -> expression . / expression
    (34) expression -> expression . ^ expression
    (35) expression -> expression . EQ expression
    (36) expression -> expression . > expression
    (37) expression -> expression . < expression
    (38) expression -> expression . NEQ expression

    ;               reduce using rule 9 (expression -> PRINT expression .)
    $end            reduce using rule 9 (expression -> PRINT expression .)
    )               reduce using rule 9 (expression -> PRINT expression .)
    }               reduce using rule 9 (expression -> PRINT expression .)
    THEN            reduce using rule 9 (expression -> PRINT expression .)
    DO              reduce using rule 9 (expression -> PRINT expression .)
    ,               reduce using rule 9 (expression -> PRINT expression .)
    ELSE            reduce using rule 9 (expression -> PRINT expression .)
    END             reduce using rule 9 (expression -> PRINT expression .)
    +               shift and go to state 30
    -               shift and go to state 31
    *               shift and go to state 32
    /               shift and go to state 33
    ^               shift and go to state 34
    EQ              shift and go to state 35
    >               shift and go to state 36
    <               shift and go to state 37
    NEQ             shift and go to state 38

  ! +               [ reduce using rule 9 (expression -> PRINT expression .) ]
  ! -               [ reduce using rule 9 (expression -> PRINT expression .) ]
  ! *               [ reduce using rule 9 (expression -> PRINT expression .) ]
  ! /               [ reduce using rule 9 (expression -> PRINT expression .) ]
  ! ^               [ reduce using rule 9 (expression -> PRINT expression .) ]
  ! EQ              [ reduce using rule 9 (expression -> PRINT expression .) ]
  ! >               [ reduce using rule 9 (expression -> PRINT expression .) ]
  ! <               [ reduce using rule 9 (expression -> PRINT expression .) ]
  ! NEQ             [ reduce using rule 9 (expression -> PRINT expression .) ]
  ! ;               [ shift and go to state 29 ]


state 47

    (40) expression -> ( expression . )
    (24) expression -> expression . ; expression
    (30) expression -> expression . + expression
    (31) expression -> expression . - expression
    (32) expression -> expression . * expression
    (33) expression -> expression . / expression
    (34) expression -> expression . ^ expression
    (35) expression -> expression . EQ expression
    (36) expression -> expression . > expression
    (37) expression -> expression . < expression
    (38) expression -> expression . NEQ expression

    )               shift and go to state 71
    ;               shift and go to state 29
    +               shift and go to state 30
    -               shift and go to state 31
    *               shift and go to state 32
    /               shift and go to state 33
    ^               shift and go to state 34
    EQ              shift and go to state 35
    >               shift and go to state 36
    <               shift and go to state 37
    NEQ             shift and go to state 38


state 48

    (23) expression -> error ; . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . NAME = expression
    (15) expression -> . type NAME = expression
    (19) expression -> . NAME ( call_args )
    (23) expression -> . error ; expression
    (24) expression -> . expression ; expression
    (25) expression -> . { expression }
    (26) expression -> . IF expression THEN expression else_expression
    (29) expression -> . WHILE expression DO expression END
    (30) expression -> . expression + expression
    (31) expression -> . expression - expression
    (32) expression -> . expression * expression
    (33) expression -> . expression / expression
    (34) expression -> . expression ^ expression
    (35) expression -> . expression EQ expression
    (36) expression -> . expression > expression
    (37) expression -> . expression < expression
    (38) expression -> . expression NEQ expression
    (39) expression -> . - expression
    (40) expression -> . ( expression )
    (41) expression -> . NUMBER
    (42) expression -> . FLOAT
    (43) expression -> . STRING
    (44) expression -> . TRUE
    (45) expression -> . FALSE
    (46) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    NAME            shift and go to state 4
    error           shift and go to state 11
    {               shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    -               shift and go to state 5
    (               shift and go to state 10
    NUMBER          shift and go to state 15
    FLOAT           shift and go to state 16
    STRING          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    2INT            shift and go to state 20
    2STR            shift and go to state 21
    2FLOAT          shift and go to state 22
    2BOOL           shift and go to state 23
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    expression                     shift and go to state 72
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 49

    (25) expression -> { expression . }
    (24) expression -> expression . ; expression
    (30) expression -> expression . + expression
    (31) expression -> expression . - expression
    (32) expression -> expression . * expression
    (33) expression -> expression . / expression
    (34) expression -> expression . ^ expression
    (35) expression -> expression . EQ expression
    (36) expression -> expression . > expression
    (37) expression -> expression . < expression
    (38) expression -> expression . NEQ expression

    }               shift and go to state 73
    ;               shift and go to state 29
    +               shift and go to state 30
    -               shift and go to state 31
    *               shift and go to state 32
    /               shift and go to state 33
    ^               shift and go to state 34
    EQ              shift and go to state 35
    >               shift and go to state 36
    <               shift and go to state 37
    NEQ             shift and go to state 38


state 50

    (26) expression -> IF expression . THEN expression else_expression
    (24) expression -> expression . ; expression
    (30) expression -> expression . + expression
    (31) expression -> expression . - expression
    (32) expression -> expression . * expression
    (33) expression -> expression . / expression
    (34) expression -> expression . ^ expression
    (35) expression -> expression . EQ expression
    (36) expression -> expression . > expression
    (37) expression -> expression . < expression
    (38) expression -> expression . NEQ expression

    THEN            shift and go to state 74
    ;               shift and go to state 29
    +               shift and go to state 30
    -               shift and go to state 31
    *               shift and go to state 32
    /               shift and go to state 33
    ^               shift and go to state 34
    EQ              shift and go to state 35
    >               shift and go to state 36
    <               shift and go to state 37
    NEQ             shift and go to state 38


state 51

    (29) expression -> WHILE expression . DO expression END
    (24) expression -> expression . ; expression
    (30) expression -> expression . + expression
    (31) expression -> expression . - expression
    (32) expression -> expression . * expression
    (33) expression -> expression . / expression
    (34) expression -> expression . ^ expression
    (35) expression -> expression . EQ expression
    (36) expression -> expression . > expression
    (37) expression -> expression . < expression
    (38) expression -> expression . NEQ expression

    DO              shift and go to state 75
    ;               shift and go to state 29
    +               shift and go to state 30
    -               shift and go to state 31
    *               shift and go to state 32
    /               shift and go to state 33
    ^               shift and go to state 34
    EQ              shift and go to state 35
    >               shift and go to state 36
    <               shift and go to state 37
    NEQ             shift and go to state 38


state 52

    (2) statement -> statement ; statement .
    (2) statement -> statement . ; statement

    ;               reduce using rule 2 (statement -> statement ; statement .)
    $end            reduce using rule 2 (statement -> statement ; statement .)

  ! ;               [ shift and go to state 28 ]


state 53

    (24) expression -> expression ; expression .
    (24) expression -> expression . ; expression
    (30) expression -> expression . + expression
    (31) expression -> expression . - expression
    (32) expression -> expression . * expression
    (33) expression -> expression . / expression
    (34) expression -> expression . ^ expression
    (35) expression -> expression . EQ expression
    (36) expression -> expression . > expression
    (37) expression -> expression . < expression
    (38) expression -> expression . NEQ expression

    ;               reduce using rule 24 (expression -> expression ; expression .)
    $end            reduce using rule 24 (expression -> expression ; expression .)
    )               reduce using rule 24 (expression -> expression ; expression .)
    }               reduce using rule 24 (expression -> expression ; expression .)
    THEN            reduce using rule 24 (expression -> expression ; expression .)
    DO              reduce using rule 24 (expression -> expression ; expression .)
    ,               reduce using rule 24 (expression -> expression ; expression .)
    ELSE            reduce using rule 24 (expression -> expression ; expression .)
    END             reduce using rule 24 (expression -> expression ; expression .)
    +               shift and go to state 30
    -               shift and go to state 31
    *               shift and go to state 32
    /               shift and go to state 33
    ^               shift and go to state 34
    EQ              shift and go to state 35
    >               shift and go to state 36
    <               shift and go to state 37
    NEQ             shift and go to state 38

  ! +               [ reduce using rule 24 (expression -> expression ; expression .) ]
  ! -               [ reduce using rule 24 (expression -> expression ; expression .) ]
  ! *               [ reduce using rule 24 (expression -> expression ; expression .) ]
  ! /               [ reduce using rule 24 (expression -> expression ; expression .) ]
  ! ^               [ reduce using rule 24 (expression -> expression ; expression .) ]
  ! EQ              [ reduce using rule 24 (expression -> expression ; expression .) ]
  ! >               [ reduce using rule 24 (expression -> expression ; expression .) ]
  ! <               [ reduce using rule 24 (expression -> expression ; expression .) ]
  ! NEQ             [ reduce using rule 24 (expression -> expression ; expression .) ]
  ! ;               [ shift and go to state 29 ]


state 54

    (30) expression -> expression + expression .
    (24) expression -> expression . ; expression
    (30) expression -> expression . + expression
    (31) expression -> expression . - expression
    (32) expression -> expression . * expression
    (33) expression -> expression . / expression
    (34) expression -> expression . ^ expression
    (35) expression -> expression . EQ expression
    (36) expression -> expression . > expression
    (37) expression -> expression . < expression
    (38) expression -> expression . NEQ expression

    ;               reduce using rule 30 (expression -> expression + expression .)
    +               reduce using rule 30 (expression -> expression + expression .)
    -               reduce using rule 30 (expression -> expression + expression .)
    EQ              reduce using rule 30 (expression -> expression + expression .)
    >               reduce using rule 30 (expression -> expression + expression .)
    <               reduce using rule 30 (expression -> expression + expression .)
    NEQ             reduce using rule 30 (expression -> expression + expression .)
    $end            reduce using rule 30 (expression -> expression + expression .)
    )               reduce using rule 30 (expression -> expression + expression .)
    }               reduce using rule 30 (expression -> expression + expression .)
    THEN            reduce using rule 30 (expression -> expression + expression .)
    DO              reduce using rule 30 (expression -> expression + expression .)
    ,               reduce using rule 30 (expression -> expression + expression .)
    ELSE            reduce using rule 30 (expression -> expression + expression .)
    END             reduce using rule 30 (expression -> expression + expression .)
    *               shift and go to state 32
    /               shift and go to state 33
    ^               shift and go to state 34

  ! *               [ reduce using rule 30 (expression -> expression + expression .) ]
  ! /               [ reduce using rule 30 (expression -> expression + expression .) ]
  ! ^               [ reduce using rule 30 (expression -> expression + expression .) ]
  ! ;               [ shift and go to state 29 ]
  ! +               [ shift and go to state 30 ]
  ! -               [ shift and go to state 31 ]
  ! EQ              [ shift and go to state 35 ]
  ! >               [ shift and go to state 36 ]
  ! <               [ shift and go to state 37 ]
  ! NEQ             [ shift and go to state 38 ]


state 55

    (31) expression -> expression - expression .
    (24) expression -> expression . ; expression
    (30) expression -> expression . + expression
    (31) expression -> expression . - expression
    (32) expression -> expression . * expression
    (33) expression -> expression . / expression
    (34) expression -> expression . ^ expression
    (35) expression -> expression . EQ expression
    (36) expression -> expression . > expression
    (37) expression -> expression . < expression
    (38) expression -> expression . NEQ expression

    ;               reduce using rule 31 (expression -> expression - expression .)
    +               reduce using rule 31 (expression -> expression - expression .)
    -               reduce using rule 31 (expression -> expression - expression .)
    EQ              reduce using rule 31 (expression -> expression - expression .)
    >               reduce using rule 31 (expression -> expression - expression .)
    <               reduce using rule 31 (expression -> expression - expression .)
    NEQ             reduce using rule 31 (expression -> expression - expression .)
    $end            reduce using rule 31 (expression -> expression - expression .)
    )               reduce using rule 31 (expression -> expression - expression .)
    }               reduce using rule 31 (expression -> expression - expression .)
    THEN            reduce using rule 31 (expression -> expression - expression .)
    DO              reduce using rule 31 (expression -> expression - expression .)
    ,               reduce using rule 31 (expression -> expression - expression .)
    ELSE            reduce using rule 31 (expression -> expression - expression .)
    END             reduce using rule 31 (expression -> expression - expression .)
    *               shift and go to state 32
    /               shift and go to state 33
    ^               shift and go to state 34

  ! *               [ reduce using rule 31 (expression -> expression - expression .) ]
  ! /               [ reduce using rule 31 (expression -> expression - expression .) ]
  ! ^               [ reduce using rule 31 (expression -> expression - expression .) ]
  ! ;               [ shift and go to state 29 ]
  ! +               [ shift and go to state 30 ]
  ! -               [ shift and go to state 31 ]
  ! EQ              [ shift and go to state 35 ]
  ! >               [ shift and go to state 36 ]
  ! <               [ shift and go to state 37 ]
  ! NEQ             [ shift and go to state 38 ]


state 56

    (32) expression -> expression * expression .
    (24) expression -> expression . ; expression
    (30) expression -> expression . + expression
    (31) expression -> expression . - expression
    (32) expression -> expression . * expression
    (33) expression -> expression . / expression
    (34) expression -> expression . ^ expression
    (35) expression -> expression . EQ expression
    (36) expression -> expression . > expression
    (37) expression -> expression . < expression
    (38) expression -> expression . NEQ expression

    ;               reduce using rule 32 (expression -> expression * expression .)
    +               reduce using rule 32 (expression -> expression * expression .)
    -               reduce using rule 32 (expression -> expression * expression .)
    *               reduce using rule 32 (expression -> expression * expression .)
    /               reduce using rule 32 (expression -> expression * expression .)
    EQ              reduce using rule 32 (expression -> expression * expression .)
    >               reduce using rule 32 (expression -> expression * expression .)
    <               reduce using rule 32 (expression -> expression * expression .)
    NEQ             reduce using rule 32 (expression -> expression * expression .)
    $end            reduce using rule 32 (expression -> expression * expression .)
    )               reduce using rule 32 (expression -> expression * expression .)
    }               reduce using rule 32 (expression -> expression * expression .)
    THEN            reduce using rule 32 (expression -> expression * expression .)
    DO              reduce using rule 32 (expression -> expression * expression .)
    ,               reduce using rule 32 (expression -> expression * expression .)
    ELSE            reduce using rule 32 (expression -> expression * expression .)
    END             reduce using rule 32 (expression -> expression * expression .)
    ^               shift and go to state 34

  ! ^               [ reduce using rule 32 (expression -> expression * expression .) ]
  ! ;               [ shift and go to state 29 ]
  ! +               [ shift and go to state 30 ]
  ! -               [ shift and go to state 31 ]
  ! *               [ shift and go to state 32 ]
  ! /               [ shift and go to state 33 ]
  ! EQ              [ shift and go to state 35 ]
  ! >               [ shift and go to state 36 ]
  ! <               [ shift and go to state 37 ]
  ! NEQ             [ shift and go to state 38 ]


state 57

    (33) expression -> expression / expression .
    (24) expression -> expression . ; expression
    (30) expression -> expression . + expression
    (31) expression -> expression . - expression
    (32) expression -> expression . * expression
    (33) expression -> expression . / expression
    (34) expression -> expression . ^ expression
    (35) expression -> expression . EQ expression
    (36) expression -> expression . > expression
    (37) expression -> expression . < expression
    (38) expression -> expression . NEQ expression

    ;               reduce using rule 33 (expression -> expression / expression .)
    +               reduce using rule 33 (expression -> expression / expression .)
    -               reduce using rule 33 (expression -> expression / expression .)
    *               reduce using rule 33 (expression -> expression / expression .)
    /               reduce using rule 33 (expression -> expression / expression .)
    EQ              reduce using rule 33 (expression -> expression / expression .)
    >               reduce using rule 33 (expression -> expression / expression .)
    <               reduce using rule 33 (expression -> expression / expression .)
    NEQ             reduce using rule 33 (expression -> expression / expression .)
    $end            reduce using rule 33 (expression -> expression / expression .)
    )               reduce using rule 33 (expression -> expression / expression .)
    }               reduce using rule 33 (expression -> expression / expression .)
    THEN            reduce using rule 33 (expression -> expression / expression .)
    DO              reduce using rule 33 (expression -> expression / expression .)
    ,               reduce using rule 33 (expression -> expression / expression .)
    ELSE            reduce using rule 33 (expression -> expression / expression .)
    END             reduce using rule 33 (expression -> expression / expression .)
    ^               shift and go to state 34

  ! ^               [ reduce using rule 33 (expression -> expression / expression .) ]
  ! ;               [ shift and go to state 29 ]
  ! +               [ shift and go to state 30 ]
  ! -               [ shift and go to state 31 ]
  ! *               [ shift and go to state 32 ]
  ! /               [ shift and go to state 33 ]
  ! EQ              [ shift and go to state 35 ]
  ! >               [ shift and go to state 36 ]
  ! <               [ shift and go to state 37 ]
  ! NEQ             [ shift and go to state 38 ]


state 58

    (34) expression -> expression ^ expression .
    (24) expression -> expression . ; expression
    (30) expression -> expression . + expression
    (31) expression -> expression . - expression
    (32) expression -> expression . * expression
    (33) expression -> expression . / expression
    (34) expression -> expression . ^ expression
    (35) expression -> expression . EQ expression
    (36) expression -> expression . > expression
    (37) expression -> expression . < expression
    (38) expression -> expression . NEQ expression

    ;               reduce using rule 34 (expression -> expression ^ expression .)
    +               reduce using rule 34 (expression -> expression ^ expression .)
    -               reduce using rule 34 (expression -> expression ^ expression .)
    *               reduce using rule 34 (expression -> expression ^ expression .)
    /               reduce using rule 34 (expression -> expression ^ expression .)
    EQ              reduce using rule 34 (expression -> expression ^ expression .)
    >               reduce using rule 34 (expression -> expression ^ expression .)
    <               reduce using rule 34 (expression -> expression ^ expression .)
    NEQ             reduce using rule 34 (expression -> expression ^ expression .)
    $end            reduce using rule 34 (expression -> expression ^ expression .)
    )               reduce using rule 34 (expression -> expression ^ expression .)
    }               reduce using rule 34 (expression -> expression ^ expression .)
    THEN            reduce using rule 34 (expression -> expression ^ expression .)
    DO              reduce using rule 34 (expression -> expression ^ expression .)
    ,               reduce using rule 34 (expression -> expression ^ expression .)
    ELSE            reduce using rule 34 (expression -> expression ^ expression .)
    END             reduce using rule 34 (expression -> expression ^ expression .)
    ^               shift and go to state 34

  ! ^               [ reduce using rule 34 (expression -> expression ^ expression .) ]
  ! ;               [ shift and go to state 29 ]
  ! +               [ shift and go to state 30 ]
  ! -               [ shift and go to state 31 ]
  ! *               [ shift and go to state 32 ]
  ! /               [ shift and go to state 33 ]
  ! EQ              [ shift and go to state 35 ]
  ! >               [ shift and go to state 36 ]
  ! <               [ shift and go to state 37 ]
  ! NEQ             [ shift and go to state 38 ]


state 59

    (35) expression -> expression EQ expression .
    (24) expression -> expression . ; expression
    (30) expression -> expression . + expression
    (31) expression -> expression . - expression
    (32) expression -> expression . * expression
    (33) expression -> expression . / expression
    (34) expression -> expression . ^ expression
    (35) expression -> expression . EQ expression
    (36) expression -> expression . > expression
    (37) expression -> expression . < expression
    (38) expression -> expression . NEQ expression

    ;               reduce using rule 35 (expression -> expression EQ expression .)
    EQ              reduce using rule 35 (expression -> expression EQ expression .)
    >               reduce using rule 35 (expression -> expression EQ expression .)
    <               reduce using rule 35 (expression -> expression EQ expression .)
    NEQ             reduce using rule 35 (expression -> expression EQ expression .)
    $end            reduce using rule 35 (expression -> expression EQ expression .)
    )               reduce using rule 35 (expression -> expression EQ expression .)
    }               reduce using rule 35 (expression -> expression EQ expression .)
    THEN            reduce using rule 35 (expression -> expression EQ expression .)
    DO              reduce using rule 35 (expression -> expression EQ expression .)
    ,               reduce using rule 35 (expression -> expression EQ expression .)
    ELSE            reduce using rule 35 (expression -> expression EQ expression .)
    END             reduce using rule 35 (expression -> expression EQ expression .)
    +               shift and go to state 30
    -               shift and go to state 31
    *               shift and go to state 32
    /               shift and go to state 33
    ^               shift and go to state 34

  ! +               [ reduce using rule 35 (expression -> expression EQ expression .) ]
  ! -               [ reduce using rule 35 (expression -> expression EQ expression .) ]
  ! *               [ reduce using rule 35 (expression -> expression EQ expression .) ]
  ! /               [ reduce using rule 35 (expression -> expression EQ expression .) ]
  ! ^               [ reduce using rule 35 (expression -> expression EQ expression .) ]
  ! ;               [ shift and go to state 29 ]
  ! EQ              [ shift and go to state 35 ]
  ! >               [ shift and go to state 36 ]
  ! <               [ shift and go to state 37 ]
  ! NEQ             [ shift and go to state 38 ]


state 60

    (36) expression -> expression > expression .
    (24) expression -> expression . ; expression
    (30) expression -> expression . + expression
    (31) expression -> expression . - expression
    (32) expression -> expression . * expression
    (33) expression -> expression . / expression
    (34) expression -> expression . ^ expression
    (35) expression -> expression . EQ expression
    (36) expression -> expression . > expression
    (37) expression -> expression . < expression
    (38) expression -> expression . NEQ expression

    ;               reduce using rule 36 (expression -> expression > expression .)
    EQ              reduce using rule 36 (expression -> expression > expression .)
    >               reduce using rule 36 (expression -> expression > expression .)
    <               reduce using rule 36 (expression -> expression > expression .)
    NEQ             reduce using rule 36 (expression -> expression > expression .)
    $end            reduce using rule 36 (expression -> expression > expression .)
    )               reduce using rule 36 (expression -> expression > expression .)
    }               reduce using rule 36 (expression -> expression > expression .)
    THEN            reduce using rule 36 (expression -> expression > expression .)
    DO              reduce using rule 36 (expression -> expression > expression .)
    ,               reduce using rule 36 (expression -> expression > expression .)
    ELSE            reduce using rule 36 (expression -> expression > expression .)
    END             reduce using rule 36 (expression -> expression > expression .)
    +               shift and go to state 30
    -               shift and go to state 31
    *               shift and go to state 32
    /               shift and go to state 33
    ^               shift and go to state 34

  ! +               [ reduce using rule 36 (expression -> expression > expression .) ]
  ! -               [ reduce using rule 36 (expression -> expression > expression .) ]
  ! *               [ reduce using rule 36 (expression -> expression > expression .) ]
  ! /               [ reduce using rule 36 (expression -> expression > expression .) ]
  ! ^               [ reduce using rule 36 (expression -> expression > expression .) ]
  ! ;               [ shift and go to state 29 ]
  ! EQ              [ shift and go to state 35 ]
  ! >               [ shift and go to state 36 ]
  ! <               [ shift and go to state 37 ]
  ! NEQ             [ shift and go to state 38 ]


state 61

    (37) expression -> expression < expression .
    (24) expression -> expression . ; expression
    (30) expression -> expression . + expression
    (31) expression -> expression . - expression
    (32) expression -> expression . * expression
    (33) expression -> expression . / expression
    (34) expression -> expression . ^ expression
    (35) expression -> expression . EQ expression
    (36) expression -> expression . > expression
    (37) expression -> expression . < expression
    (38) expression -> expression . NEQ expression

    ;               reduce using rule 37 (expression -> expression < expression .)
    EQ              reduce using rule 37 (expression -> expression < expression .)
    >               reduce using rule 37 (expression -> expression < expression .)
    <               reduce using rule 37 (expression -> expression < expression .)
    NEQ             reduce using rule 37 (expression -> expression < expression .)
    $end            reduce using rule 37 (expression -> expression < expression .)
    )               reduce using rule 37 (expression -> expression < expression .)
    }               reduce using rule 37 (expression -> expression < expression .)
    THEN            reduce using rule 37 (expression -> expression < expression .)
    DO              reduce using rule 37 (expression -> expression < expression .)
    ,               reduce using rule 37 (expression -> expression < expression .)
    ELSE            reduce using rule 37 (expression -> expression < expression .)
    END             reduce using rule 37 (expression -> expression < expression .)
    +               shift and go to state 30
    -               shift and go to state 31
    *               shift and go to state 32
    /               shift and go to state 33
    ^               shift and go to state 34

  ! +               [ reduce using rule 37 (expression -> expression < expression .) ]
  ! -               [ reduce using rule 37 (expression -> expression < expression .) ]
  ! *               [ reduce using rule 37 (expression -> expression < expression .) ]
  ! /               [ reduce using rule 37 (expression -> expression < expression .) ]
  ! ^               [ reduce using rule 37 (expression -> expression < expression .) ]
  ! ;               [ shift and go to state 29 ]
  ! EQ              [ shift and go to state 35 ]
  ! >               [ shift and go to state 36 ]
  ! <               [ shift and go to state 37 ]
  ! NEQ             [ shift and go to state 38 ]


state 62

    (38) expression -> expression NEQ expression .
    (24) expression -> expression . ; expression
    (30) expression -> expression . + expression
    (31) expression -> expression . - expression
    (32) expression -> expression . * expression
    (33) expression -> expression . / expression
    (34) expression -> expression . ^ expression
    (35) expression -> expression . EQ expression
    (36) expression -> expression . > expression
    (37) expression -> expression . < expression
    (38) expression -> expression . NEQ expression

    ;               reduce using rule 38 (expression -> expression NEQ expression .)
    EQ              reduce using rule 38 (expression -> expression NEQ expression .)
    >               reduce using rule 38 (expression -> expression NEQ expression .)
    <               reduce using rule 38 (expression -> expression NEQ expression .)
    NEQ             reduce using rule 38 (expression -> expression NEQ expression .)
    $end            reduce using rule 38 (expression -> expression NEQ expression .)
    )               reduce using rule 38 (expression -> expression NEQ expression .)
    }               reduce using rule 38 (expression -> expression NEQ expression .)
    THEN            reduce using rule 38 (expression -> expression NEQ expression .)
    DO              reduce using rule 38 (expression -> expression NEQ expression .)
    ,               reduce using rule 38 (expression -> expression NEQ expression .)
    ELSE            reduce using rule 38 (expression -> expression NEQ expression .)
    END             reduce using rule 38 (expression -> expression NEQ expression .)
    +               shift and go to state 30
    -               shift and go to state 31
    *               shift and go to state 32
    /               shift and go to state 33
    ^               shift and go to state 34

  ! +               [ reduce using rule 38 (expression -> expression NEQ expression .) ]
  ! -               [ reduce using rule 38 (expression -> expression NEQ expression .) ]
  ! *               [ reduce using rule 38 (expression -> expression NEQ expression .) ]
  ! /               [ reduce using rule 38 (expression -> expression NEQ expression .) ]
  ! ^               [ reduce using rule 38 (expression -> expression NEQ expression .) ]
  ! ;               [ shift and go to state 29 ]
  ! EQ              [ shift and go to state 35 ]
  ! >               [ shift and go to state 36 ]
  ! <               [ shift and go to state 37 ]
  ! NEQ             [ shift and go to state 38 ]


state 63

    (16) statement -> DEF NAME args . - > type = expression

    -               shift and go to state 76


state 64

    (18) args -> type . NAME args

    NAME            shift and go to state 77


state 65

    (17) args -> empty .

    -               reduce using rule 17 (args -> empty .)


state 66

    (10) expression -> NAME = expression .
    (24) expression -> expression . ; expression
    (30) expression -> expression . + expression
    (31) expression -> expression . - expression
    (32) expression -> expression . * expression
    (33) expression -> expression . / expression
    (34) expression -> expression . ^ expression
    (35) expression -> expression . EQ expression
    (36) expression -> expression . > expression
    (37) expression -> expression . < expression
    (38) expression -> expression . NEQ expression

    ;               reduce using rule 10 (expression -> NAME = expression .)
    EQ              reduce using rule 10 (expression -> NAME = expression .)
    >               reduce using rule 10 (expression -> NAME = expression .)
    <               reduce using rule 10 (expression -> NAME = expression .)
    NEQ             reduce using rule 10 (expression -> NAME = expression .)
    $end            reduce using rule 10 (expression -> NAME = expression .)
    )               reduce using rule 10 (expression -> NAME = expression .)
    }               reduce using rule 10 (expression -> NAME = expression .)
    THEN            reduce using rule 10 (expression -> NAME = expression .)
    DO              reduce using rule 10 (expression -> NAME = expression .)
    ,               reduce using rule 10 (expression -> NAME = expression .)
    ELSE            reduce using rule 10 (expression -> NAME = expression .)
    END             reduce using rule 10 (expression -> NAME = expression .)
    +               shift and go to state 30
    -               shift and go to state 31
    *               shift and go to state 32
    /               shift and go to state 33
    ^               shift and go to state 34

  ! +               [ reduce using rule 10 (expression -> NAME = expression .) ]
  ! -               [ reduce using rule 10 (expression -> NAME = expression .) ]
  ! *               [ reduce using rule 10 (expression -> NAME = expression .) ]
  ! /               [ reduce using rule 10 (expression -> NAME = expression .) ]
  ! ^               [ reduce using rule 10 (expression -> NAME = expression .) ]
  ! ;               [ shift and go to state 29 ]
  ! EQ              [ shift and go to state 35 ]
  ! >               [ shift and go to state 36 ]
  ! <               [ shift and go to state 37 ]
  ! NEQ             [ shift and go to state 38 ]


state 67

    (19) expression -> NAME ( call_args . )

    )               shift and go to state 78


state 68

    (20) call_args -> empty .

    )               reduce using rule 20 (call_args -> empty .)


state 69

    (21) call_args -> expression .
    (22) call_args -> expression . , call_args
    (24) expression -> expression . ; expression
    (30) expression -> expression . + expression
    (31) expression -> expression . - expression
    (32) expression -> expression . * expression
    (33) expression -> expression . / expression
    (34) expression -> expression . ^ expression
    (35) expression -> expression . EQ expression
    (36) expression -> expression . > expression
    (37) expression -> expression . < expression
    (38) expression -> expression . NEQ expression

    )               reduce using rule 21 (call_args -> expression .)
    ,               shift and go to state 79
    ;               shift and go to state 29
    +               shift and go to state 30
    -               shift and go to state 31
    *               shift and go to state 32
    /               shift and go to state 33
    ^               shift and go to state 34
    EQ              shift and go to state 35
    >               shift and go to state 36
    <               shift and go to state 37
    NEQ             shift and go to state 38


state 70

    (15) expression -> type NAME = . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . NAME = expression
    (15) expression -> . type NAME = expression
    (19) expression -> . NAME ( call_args )
    (23) expression -> . error ; expression
    (24) expression -> . expression ; expression
    (25) expression -> . { expression }
    (26) expression -> . IF expression THEN expression else_expression
    (29) expression -> . WHILE expression DO expression END
    (30) expression -> . expression + expression
    (31) expression -> . expression - expression
    (32) expression -> . expression * expression
    (33) expression -> . expression / expression
    (34) expression -> . expression ^ expression
    (35) expression -> . expression EQ expression
    (36) expression -> . expression > expression
    (37) expression -> . expression < expression
    (38) expression -> . expression NEQ expression
    (39) expression -> . - expression
    (40) expression -> . ( expression )
    (41) expression -> . NUMBER
    (42) expression -> . FLOAT
    (43) expression -> . STRING
    (44) expression -> . TRUE
    (45) expression -> . FALSE
    (46) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    NAME            shift and go to state 4
    error           shift and go to state 11
    {               shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    -               shift and go to state 5
    (               shift and go to state 10
    NUMBER          shift and go to state 15
    FLOAT           shift and go to state 16
    STRING          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    2INT            shift and go to state 20
    2STR            shift and go to state 21
    2FLOAT          shift and go to state 22
    2BOOL           shift and go to state 23
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    type                           shift and go to state 6
    expression                     shift and go to state 80
    convert                        shift and go to state 7

state 71

    (40) expression -> ( expression ) .

    ;               reduce using rule 40 (expression -> ( expression ) .)
    +               reduce using rule 40 (expression -> ( expression ) .)
    -               reduce using rule 40 (expression -> ( expression ) .)
    *               reduce using rule 40 (expression -> ( expression ) .)
    /               reduce using rule 40 (expression -> ( expression ) .)
    ^               reduce using rule 40 (expression -> ( expression ) .)
    EQ              reduce using rule 40 (expression -> ( expression ) .)
    >               reduce using rule 40 (expression -> ( expression ) .)
    <               reduce using rule 40 (expression -> ( expression ) .)
    NEQ             reduce using rule 40 (expression -> ( expression ) .)
    $end            reduce using rule 40 (expression -> ( expression ) .)
    )               reduce using rule 40 (expression -> ( expression ) .)
    }               reduce using rule 40 (expression -> ( expression ) .)
    THEN            reduce using rule 40 (expression -> ( expression ) .)
    DO              reduce using rule 40 (expression -> ( expression ) .)
    ,               reduce using rule 40 (expression -> ( expression ) .)
    ELSE            reduce using rule 40 (expression -> ( expression ) .)
    END             reduce using rule 40 (expression -> ( expression ) .)


state 72

    (23) expression -> error ; expression .
    (24) expression -> expression . ; expression
    (30) expression -> expression . + expression
    (31) expression -> expression . - expression
    (32) expression -> expression . * expression
    (33) expression -> expression . / expression
    (34) expression -> expression . ^ expression
    (35) expression -> expression . EQ expression
    (36) expression -> expression . > expression
    (37) expression -> expression . < expression
    (38) expression -> expression . NEQ expression

    ;               reduce using rule 23 (expression -> error ; expression .)
    $end            reduce using rule 23 (expression -> error ; expression .)
    )               reduce using rule 23 (expression -> error ; expression .)
    }               reduce using rule 23 (expression -> error ; expression .)
    THEN            reduce using rule 23 (expression -> error ; expression .)
    DO              reduce using rule 23 (expression -> error ; expression .)
    ,               reduce using rule 23 (expression -> error ; expression .)
    ELSE            reduce using rule 23 (expression -> error ; expression .)
    END             reduce using rule 23 (expression -> error ; expression .)
    +               shift and go to state 30
    -               shift and go to state 31
    *               shift and go to state 32
    /               shift and go to state 33
    ^               shift and go to state 34
    EQ              shift and go to state 35
    >               shift and go to state 36
    <               shift and go to state 37
    NEQ             shift and go to state 38

  ! +               [ reduce using rule 23 (expression -> error ; expression .) ]
  ! -               [ reduce using rule 23 (expression -> error ; expression .) ]
  ! *               [ reduce using rule 23 (expression -> error ; expression .) ]
  ! /               [ reduce using rule 23 (expression -> error ; expression .) ]
  ! ^               [ reduce using rule 23 (expression -> error ; expression .) ]
  ! EQ              [ reduce using rule 23 (expression -> error ; expression .) ]
  ! >               [ reduce using rule 23 (expression -> error ; expression .) ]
  ! <               [ reduce using rule 23 (expression -> error ; expression .) ]
  ! NEQ             [ reduce using rule 23 (expression -> error ; expression .) ]
  ! ;               [ shift and go to state 29 ]


state 73

    (25) expression -> { expression } .

    ;               reduce using rule 25 (expression -> { expression } .)
    +               reduce using rule 25 (expression -> { expression } .)
    -               reduce using rule 25 (expression -> { expression } .)
    *               reduce using rule 25 (expression -> { expression } .)
    /               reduce using rule 25 (expression -> { expression } .)
    ^               reduce using rule 25 (expression -> { expression } .)
    EQ              reduce using rule 25 (expression -> { expression } .)
    >               reduce using rule 25 (expression -> { expression } .)
    <               reduce using rule 25 (expression -> { expression } .)
    NEQ             reduce using rule 25 (expression -> { expression } .)
    $end            reduce using rule 25 (expression -> { expression } .)
    )               reduce using rule 25 (expression -> { expression } .)
    }               reduce using rule 25 (expression -> { expression } .)
    THEN            reduce using rule 25 (expression -> { expression } .)
    DO              reduce using rule 25 (expression -> { expression } .)
    ,               reduce using rule 25 (expression -> { expression } .)
    ELSE            reduce using rule 25 (expression -> { expression } .)
    END             reduce using rule 25 (expression -> { expression } .)


state 74

    (26) expression -> IF expression THEN . expression else_expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . NAME = expression
    (15) expression -> . type NAME = expression
    (19) expression -> . NAME ( call_args )
    (23) expression -> . error ; expression
    (24) expression -> . expression ; expression
    (25) expression -> . { expression }
    (26) expression -> . IF expression THEN expression else_expression
    (29) expression -> . WHILE expression DO expression END
    (30) expression -> . expression + expression
    (31) expression -> . expression - expression
    (32) expression -> . expression * expression
    (33) expression -> . expression / expression
    (34) expression -> . expression ^ expression
    (35) expression -> . expression EQ expression
    (36) expression -> . expression > expression
    (37) expression -> . expression < expression
    (38) expression -> . expression NEQ expression
    (39) expression -> . - expression
    (40) expression -> . ( expression )
    (41) expression -> . NUMBER
    (42) expression -> . FLOAT
    (43) expression -> . STRING
    (44) expression -> . TRUE
    (45) expression -> . FALSE
    (46) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    NAME            shift and go to state 4
    error           shift and go to state 11
    {               shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    -               shift and go to state 5
    (               shift and go to state 10
    NUMBER          shift and go to state 15
    FLOAT           shift and go to state 16
    STRING          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    2INT            shift and go to state 20
    2STR            shift and go to state 21
    2FLOAT          shift and go to state 22
    2BOOL           shift and go to state 23
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    expression                     shift and go to state 81
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 75

    (29) expression -> WHILE expression DO . expression END
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . NAME = expression
    (15) expression -> . type NAME = expression
    (19) expression -> . NAME ( call_args )
    (23) expression -> . error ; expression
    (24) expression -> . expression ; expression
    (25) expression -> . { expression }
    (26) expression -> . IF expression THEN expression else_expression
    (29) expression -> . WHILE expression DO expression END
    (30) expression -> . expression + expression
    (31) expression -> . expression - expression
    (32) expression -> . expression * expression
    (33) expression -> . expression / expression
    (34) expression -> . expression ^ expression
    (35) expression -> . expression EQ expression
    (36) expression -> . expression > expression
    (37) expression -> . expression < expression
    (38) expression -> . expression NEQ expression
    (39) expression -> . - expression
    (40) expression -> . ( expression )
    (41) expression -> . NUMBER
    (42) expression -> . FLOAT
    (43) expression -> . STRING
    (44) expression -> . TRUE
    (45) expression -> . FALSE
    (46) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    NAME            shift and go to state 4
    error           shift and go to state 11
    {               shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    -               shift and go to state 5
    (               shift and go to state 10
    NUMBER          shift and go to state 15
    FLOAT           shift and go to state 16
    STRING          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    2INT            shift and go to state 20
    2STR            shift and go to state 21
    2FLOAT          shift and go to state 22
    2BOOL           shift and go to state 23
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    expression                     shift and go to state 82
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 76

    (16) statement -> DEF NAME args - . > type = expression

    >               shift and go to state 83


state 77

    (18) args -> type NAME . args
    (17) args -> . empty
    (18) args -> . type NAME args
    (47) empty -> .
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    -               reduce using rule 47 (empty -> .)
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    type                           shift and go to state 64
    args                           shift and go to state 84
    empty                          shift and go to state 65

state 78

    (19) expression -> NAME ( call_args ) .

    ;               reduce using rule 19 (expression -> NAME ( call_args ) .)
    +               reduce using rule 19 (expression -> NAME ( call_args ) .)
    -               reduce using rule 19 (expression -> NAME ( call_args ) .)
    *               reduce using rule 19 (expression -> NAME ( call_args ) .)
    /               reduce using rule 19 (expression -> NAME ( call_args ) .)
    ^               reduce using rule 19 (expression -> NAME ( call_args ) .)
    EQ              reduce using rule 19 (expression -> NAME ( call_args ) .)
    >               reduce using rule 19 (expression -> NAME ( call_args ) .)
    <               reduce using rule 19 (expression -> NAME ( call_args ) .)
    NEQ             reduce using rule 19 (expression -> NAME ( call_args ) .)
    $end            reduce using rule 19 (expression -> NAME ( call_args ) .)
    )               reduce using rule 19 (expression -> NAME ( call_args ) .)
    }               reduce using rule 19 (expression -> NAME ( call_args ) .)
    THEN            reduce using rule 19 (expression -> NAME ( call_args ) .)
    DO              reduce using rule 19 (expression -> NAME ( call_args ) .)
    ,               reduce using rule 19 (expression -> NAME ( call_args ) .)
    ELSE            reduce using rule 19 (expression -> NAME ( call_args ) .)
    END             reduce using rule 19 (expression -> NAME ( call_args ) .)


state 79

    (22) call_args -> expression , . call_args
    (20) call_args -> . empty
    (21) call_args -> . expression
    (22) call_args -> . expression , call_args
    (47) empty -> .
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . NAME = expression
    (15) expression -> . type NAME = expression
    (19) expression -> . NAME ( call_args )
    (23) expression -> . error ; expression
    (24) expression -> . expression ; expression
    (25) expression -> . { expression }
    (26) expression -> . IF expression THEN expression else_expression
    (29) expression -> . WHILE expression DO expression END
    (30) expression -> . expression + expression
    (31) expression -> . expression - expression
    (32) expression -> . expression * expression
    (33) expression -> . expression / expression
    (34) expression -> . expression ^ expression
    (35) expression -> . expression EQ expression
    (36) expression -> . expression > expression
    (37) expression -> . expression < expression
    (38) expression -> . expression NEQ expression
    (39) expression -> . - expression
    (40) expression -> . ( expression )
    (41) expression -> . NUMBER
    (42) expression -> . FLOAT
    (43) expression -> . STRING
    (44) expression -> . TRUE
    (45) expression -> . FALSE
    (46) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    )               reduce using rule 47 (empty -> .)
    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    NAME            shift and go to state 4
    error           shift and go to state 11
    {               shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    -               shift and go to state 5
    (               shift and go to state 10
    NUMBER          shift and go to state 15
    FLOAT           shift and go to state 16
    STRING          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    2INT            shift and go to state 20
    2STR            shift and go to state 21
    2FLOAT          shift and go to state 22
    2BOOL           shift and go to state 23
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    expression                     shift and go to state 69
    call_args                      shift and go to state 85
    empty                          shift and go to state 68
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 80

    (15) expression -> type NAME = expression .
    (24) expression -> expression . ; expression
    (30) expression -> expression . + expression
    (31) expression -> expression . - expression
    (32) expression -> expression . * expression
    (33) expression -> expression . / expression
    (34) expression -> expression . ^ expression
    (35) expression -> expression . EQ expression
    (36) expression -> expression . > expression
    (37) expression -> expression . < expression
    (38) expression -> expression . NEQ expression

    ;               reduce using rule 15 (expression -> type NAME = expression .)
    EQ              reduce using rule 15 (expression -> type NAME = expression .)
    >               reduce using rule 15 (expression -> type NAME = expression .)
    <               reduce using rule 15 (expression -> type NAME = expression .)
    NEQ             reduce using rule 15 (expression -> type NAME = expression .)
    $end            reduce using rule 15 (expression -> type NAME = expression .)
    )               reduce using rule 15 (expression -> type NAME = expression .)
    }               reduce using rule 15 (expression -> type NAME = expression .)
    THEN            reduce using rule 15 (expression -> type NAME = expression .)
    DO              reduce using rule 15 (expression -> type NAME = expression .)
    ,               reduce using rule 15 (expression -> type NAME = expression .)
    ELSE            reduce using rule 15 (expression -> type NAME = expression .)
    END             reduce using rule 15 (expression -> type NAME = expression .)
    +               shift and go to state 30
    -               shift and go to state 31
    *               shift and go to state 32
    /               shift and go to state 33
    ^               shift and go to state 34

  ! +               [ reduce using rule 15 (expression -> type NAME = expression .) ]
  ! -               [ reduce using rule 15 (expression -> type NAME = expression .) ]
  ! *               [ reduce using rule 15 (expression -> type NAME = expression .) ]
  ! /               [ reduce using rule 15 (expression -> type NAME = expression .) ]
  ! ^               [ reduce using rule 15 (expression -> type NAME = expression .) ]
  ! ;               [ shift and go to state 29 ]
  ! EQ              [ shift and go to state 35 ]
  ! >               [ shift and go to state 36 ]
  ! <               [ shift and go to state 37 ]
  ! NEQ             [ shift and go to state 38 ]


state 81

    (26) expression -> IF expression THEN expression . else_expression
    (24) expression -> expression . ; expression
    (30) expression -> expression . + expression
    (31) expression -> expression . - expression
    (32) expression -> expression . * expression
    (33) expression -> expression . / expression
    (34) expression -> expression . ^ expression
    (35) expression -> expression . EQ expression
    (36) expression -> expression . > expression
    (37) expression -> expression . < expression
    (38) expression -> expression . NEQ expression
    (27) else_expression -> . ELSE expression
    (28) else_expression -> . empty
    (47) empty -> .

  ! shift/reduce conflict for ; resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
    ;               shift and go to state 29
    +               shift and go to state 30
    -               shift and go to state 31
    *               shift and go to state 32
    /               shift and go to state 33
    ^               shift and go to state 34
    EQ              shift and go to state 35
    >               shift and go to state 36
    <               shift and go to state 37
    NEQ             shift and go to state 38
    ELSE            shift and go to state 87
    $end            reduce using rule 47 (empty -> .)
    )               reduce using rule 47 (empty -> .)
    }               reduce using rule 47 (empty -> .)
    THEN            reduce using rule 47 (empty -> .)
    DO              reduce using rule 47 (empty -> .)
    ,               reduce using rule 47 (empty -> .)
    END             reduce using rule 47 (empty -> .)

  ! ;               [ reduce using rule 47 (empty -> .) ]
  ! +               [ reduce using rule 47 (empty -> .) ]
  ! -               [ reduce using rule 47 (empty -> .) ]
  ! *               [ reduce using rule 47 (empty -> .) ]
  ! /               [ reduce using rule 47 (empty -> .) ]
  ! ^               [ reduce using rule 47 (empty -> .) ]
  ! EQ              [ reduce using rule 47 (empty -> .) ]
  ! >               [ reduce using rule 47 (empty -> .) ]
  ! <               [ reduce using rule 47 (empty -> .) ]
  ! NEQ             [ reduce using rule 47 (empty -> .) ]
  ! ELSE            [ reduce using rule 47 (empty -> .) ]

    else_expression                shift and go to state 86
    empty                          shift and go to state 88

state 82

    (29) expression -> WHILE expression DO expression . END
    (24) expression -> expression . ; expression
    (30) expression -> expression . + expression
    (31) expression -> expression . - expression
    (32) expression -> expression . * expression
    (33) expression -> expression . / expression
    (34) expression -> expression . ^ expression
    (35) expression -> expression . EQ expression
    (36) expression -> expression . > expression
    (37) expression -> expression . < expression
    (38) expression -> expression . NEQ expression

    END             shift and go to state 89
    ;               shift and go to state 29
    +               shift and go to state 30
    -               shift and go to state 31
    *               shift and go to state 32
    /               shift and go to state 33
    ^               shift and go to state 34
    EQ              shift and go to state 35
    >               shift and go to state 36
    <               shift and go to state 37
    NEQ             shift and go to state 38


state 83

    (16) statement -> DEF NAME args - > . type = expression
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    type                           shift and go to state 90

state 84

    (18) args -> type NAME args .

    -               reduce using rule 18 (args -> type NAME args .)


state 85

    (22) call_args -> expression , call_args .

    )               reduce using rule 22 (call_args -> expression , call_args .)


state 86

    (26) expression -> IF expression THEN expression else_expression .

    ;               reduce using rule 26 (expression -> IF expression THEN expression else_expression .)
    +               reduce using rule 26 (expression -> IF expression THEN expression else_expression .)
    -               reduce using rule 26 (expression -> IF expression THEN expression else_expression .)
    *               reduce using rule 26 (expression -> IF expression THEN expression else_expression .)
    /               reduce using rule 26 (expression -> IF expression THEN expression else_expression .)
    ^               reduce using rule 26 (expression -> IF expression THEN expression else_expression .)
    EQ              reduce using rule 26 (expression -> IF expression THEN expression else_expression .)
    >               reduce using rule 26 (expression -> IF expression THEN expression else_expression .)
    <               reduce using rule 26 (expression -> IF expression THEN expression else_expression .)
    NEQ             reduce using rule 26 (expression -> IF expression THEN expression else_expression .)
    $end            reduce using rule 26 (expression -> IF expression THEN expression else_expression .)
    )               reduce using rule 26 (expression -> IF expression THEN expression else_expression .)
    }               reduce using rule 26 (expression -> IF expression THEN expression else_expression .)
    THEN            reduce using rule 26 (expression -> IF expression THEN expression else_expression .)
    DO              reduce using rule 26 (expression -> IF expression THEN expression else_expression .)
    ,               reduce using rule 26 (expression -> IF expression THEN expression else_expression .)
    ELSE            reduce using rule 26 (expression -> IF expression THEN expression else_expression .)
    END             reduce using rule 26 (expression -> IF expression THEN expression else_expression .)


state 87

    (27) else_expression -> ELSE . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . NAME = expression
    (15) expression -> . type NAME = expression
    (19) expression -> . NAME ( call_args )
    (23) expression -> . error ; expression
    (24) expression -> . expression ; expression
    (25) expression -> . { expression }
    (26) expression -> . IF expression THEN expression else_expression
    (29) expression -> . WHILE expression DO expression END
    (30) expression -> . expression + expression
    (31) expression -> . expression - expression
    (32) expression -> . expression * expression
    (33) expression -> . expression / expression
    (34) expression -> . expression ^ expression
    (35) expression -> . expression EQ expression
    (36) expression -> . expression > expression
    (37) expression -> . expression < expression
    (38) expression -> . expression NEQ expression
    (39) expression -> . - expression
    (40) expression -> . ( expression )
    (41) expression -> . NUMBER
    (42) expression -> . FLOAT
    (43) expression -> . STRING
    (44) expression -> . TRUE
    (45) expression -> . FALSE
    (46) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    NAME            shift and go to state 4
    error           shift and go to state 11
    {               shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    -               shift and go to state 5
    (               shift and go to state 10
    NUMBER          shift and go to state 15
    FLOAT           shift and go to state 16
    STRING          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    2INT            shift and go to state 20
    2STR            shift and go to state 21
    2FLOAT          shift and go to state 22
    2BOOL           shift and go to state 23
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    expression                     shift and go to state 91
    convert                        shift and go to state 7
    type                           shift and go to state 6

state 88

    (28) else_expression -> empty .

    ;               reduce using rule 28 (else_expression -> empty .)
    +               reduce using rule 28 (else_expression -> empty .)
    -               reduce using rule 28 (else_expression -> empty .)
    *               reduce using rule 28 (else_expression -> empty .)
    /               reduce using rule 28 (else_expression -> empty .)
    ^               reduce using rule 28 (else_expression -> empty .)
    EQ              reduce using rule 28 (else_expression -> empty .)
    >               reduce using rule 28 (else_expression -> empty .)
    <               reduce using rule 28 (else_expression -> empty .)
    NEQ             reduce using rule 28 (else_expression -> empty .)
    $end            reduce using rule 28 (else_expression -> empty .)
    )               reduce using rule 28 (else_expression -> empty .)
    }               reduce using rule 28 (else_expression -> empty .)
    THEN            reduce using rule 28 (else_expression -> empty .)
    DO              reduce using rule 28 (else_expression -> empty .)
    ,               reduce using rule 28 (else_expression -> empty .)
    ELSE            reduce using rule 28 (else_expression -> empty .)
    END             reduce using rule 28 (else_expression -> empty .)


state 89

    (29) expression -> WHILE expression DO expression END .

    ;               reduce using rule 29 (expression -> WHILE expression DO expression END .)
    +               reduce using rule 29 (expression -> WHILE expression DO expression END .)
    -               reduce using rule 29 (expression -> WHILE expression DO expression END .)
    *               reduce using rule 29 (expression -> WHILE expression DO expression END .)
    /               reduce using rule 29 (expression -> WHILE expression DO expression END .)
    ^               reduce using rule 29 (expression -> WHILE expression DO expression END .)
    EQ              reduce using rule 29 (expression -> WHILE expression DO expression END .)
    >               reduce using rule 29 (expression -> WHILE expression DO expression END .)
    <               reduce using rule 29 (expression -> WHILE expression DO expression END .)
    NEQ             reduce using rule 29 (expression -> WHILE expression DO expression END .)
    $end            reduce using rule 29 (expression -> WHILE expression DO expression END .)
    )               reduce using rule 29 (expression -> WHILE expression DO expression END .)
    }               reduce using rule 29 (expression -> WHILE expression DO expression END .)
    THEN            reduce using rule 29 (expression -> WHILE expression DO expression END .)
    DO              reduce using rule 29 (expression -> WHILE expression DO expression END .)
    ,               reduce using rule 29 (expression -> WHILE expression DO expression END .)
    ELSE            reduce using rule 29 (expression -> WHILE expression DO expression END .)
    END             reduce using rule 29 (expression -> WHILE expression DO expression END .)


state 90

    (16) statement -> DEF NAME args - > type . = expression

    =               shift and go to state 92


state 91

    (27) else_expression -> ELSE expression .
    (24) expression -> expression . ; expression
    (30) expression -> expression . + expression
    (31) expression -> expression . - expression
    (32) expression -> expression . * expression
    (33) expression -> expression . / expression
    (34) expression -> expression . ^ expression
    (35) expression -> expression . EQ expression
    (36) expression -> expression . > expression
    (37) expression -> expression . < expression
    (38) expression -> expression . NEQ expression

    $end            reduce using rule 27 (else_expression -> ELSE expression .)
    )               reduce using rule 27 (else_expression -> ELSE expression .)
    }               reduce using rule 27 (else_expression -> ELSE expression .)
    THEN            reduce using rule 27 (else_expression -> ELSE expression .)
    DO              reduce using rule 27 (else_expression -> ELSE expression .)
    ,               reduce using rule 27 (else_expression -> ELSE expression .)
    ELSE            reduce using rule 27 (else_expression -> ELSE expression .)
    END             reduce using rule 27 (else_expression -> ELSE expression .)
    ;               shift and go to state 29
    +               shift and go to state 30
    -               shift and go to state 31
    *               shift and go to state 32
    /               shift and go to state 33
    ^               shift and go to state 34
    EQ              shift and go to state 35
    >               shift and go to state 36
    <               shift and go to state 37
    NEQ             shift and go to state 38

  ! ;               [ reduce using rule 27 (else_expression -> ELSE expression .) ]
  ! +               [ reduce using rule 27 (else_expression -> ELSE expression .) ]
  ! -               [ reduce using rule 27 (else_expression -> ELSE expression .) ]
  ! *               [ reduce using rule 27 (else_expression -> ELSE expression .) ]
  ! /               [ reduce using rule 27 (else_expression -> ELSE expression .) ]
  ! ^               [ reduce using rule 27 (else_expression -> ELSE expression .) ]
  ! EQ              [ reduce using rule 27 (else_expression -> ELSE expression .) ]
  ! >               [ reduce using rule 27 (else_expression -> ELSE expression .) ]
  ! <               [ reduce using rule 27 (else_expression -> ELSE expression .) ]
  ! NEQ             [ reduce using rule 27 (else_expression -> ELSE expression .) ]


state 92

    (16) statement -> DEF NAME args - > type = . expression
    (7) expression -> . convert expression
    (8) expression -> . NOT expression
    (9) expression -> . PRINT expression
    (10) expression -> . NAME = expression
    (15) expression -> . type NAME = expression
    (19) expression -> . NAME ( call_args )
    (23) expression -> . error ; expression
    (24) expression -> . expression ; expression
    (25) expression -> . { expression }
    (26) expression -> . IF expression THEN expression else_expression
    (29) expression -> . WHILE expression DO expression END
    (30) expression -> . expression + expression
    (31) expression -> . expression - expression
    (32) expression -> . expression * expression
    (33) expression -> . expression / expression
    (34) expression -> . expression ^ expression
    (35) expression -> . expression EQ expression
    (36) expression -> . expression > expression
    (37) expression -> . expression < expression
    (38) expression -> . expression NEQ expression
    (39) expression -> . - expression
    (40) expression -> . ( expression )
    (41) expression -> . NUMBER
    (42) expression -> . FLOAT
    (43) expression -> . STRING
    (44) expression -> . TRUE
    (45) expression -> . FALSE
    (46) expression -> . NAME
    (3) convert -> . 2INT
    (4) convert -> . 2STR
    (5) convert -> . 2FLOAT
    (6) convert -> . 2BOOL
    (11) type -> . STRING_TYPE
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE

    NOT             shift and go to state 8
    PRINT           shift and go to state 9
    NAME            shift and go to state 4
    error           shift and go to state 11
    {               shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    -               shift and go to state 5
    (               shift and go to state 10
    NUMBER          shift and go to state 15
    FLOAT           shift and go to state 16
    STRING          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    2INT            shift and go to state 20
    2STR            shift and go to state 21
    2FLOAT          shift and go to state 22
    2BOOL           shift and go to state 23
    STRING_TYPE     shift and go to state 24
    INT_TYPE        shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    type                           shift and go to state 6
    expression                     shift and go to state 93
    convert                        shift and go to state 7

state 93

    (16) statement -> DEF NAME args - > type = expression .
    (24) expression -> expression . ; expression
    (30) expression -> expression . + expression
    (31) expression -> expression . - expression
    (32) expression -> expression . * expression
    (33) expression -> expression . / expression
    (34) expression -> expression . ^ expression
    (35) expression -> expression . EQ expression
    (36) expression -> expression . > expression
    (37) expression -> expression . < expression
    (38) expression -> expression . NEQ expression

    ;               reduce using rule 16 (statement -> DEF NAME args - > type = expression .)
    $end            reduce using rule 16 (statement -> DEF NAME args - > type = expression .)
    +               shift and go to state 30
    -               shift and go to state 31
    *               shift and go to state 32
    /               shift and go to state 33
    ^               shift and go to state 34
    EQ              shift and go to state 35
    >               shift and go to state 36
    <               shift and go to state 37
    NEQ             shift and go to state 38

  ! ;               [ shift and go to state 29 ]

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ; in state 2 resolved as shift
WARNING: shift/reduce conflict for ; in state 44 resolved as shift
WARNING: shift/reduce conflict for + in state 44 resolved as shift
WARNING: shift/reduce conflict for - in state 44 resolved as shift
WARNING: shift/reduce conflict for * in state 44 resolved as shift
WARNING: shift/reduce conflict for / in state 44 resolved as shift
WARNING: shift/reduce conflict for ^ in state 44 resolved as shift
WARNING: shift/reduce conflict for EQ in state 44 resolved as shift
WARNING: shift/reduce conflict for > in state 44 resolved as shift
WARNING: shift/reduce conflict for < in state 44 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 44 resolved as shift
WARNING: shift/reduce conflict for ; in state 81 resolved as shift
WARNING: shift/reduce conflict for + in state 81 resolved as shift
WARNING: shift/reduce conflict for - in state 81 resolved as shift
WARNING: shift/reduce conflict for * in state 81 resolved as shift
WARNING: shift/reduce conflict for / in state 81 resolved as shift
WARNING: shift/reduce conflict for ^ in state 81 resolved as shift
WARNING: shift/reduce conflict for EQ in state 81 resolved as shift
WARNING: shift/reduce conflict for > in state 81 resolved as shift
WARNING: shift/reduce conflict for < in state 81 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 81 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 81 resolved as shift
